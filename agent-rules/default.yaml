# CAD AI Studio - Default Agent Rules
# This file configures how the AI generates CadQuery code
# Users can customize this to improve accuracy for their use cases

version: 1

# =============================================================================
# COORDINATE SYSTEM
# =============================================================================
coordinate_system:
  description: "Right-hand coordinate system"
  x:
    direction: "length / front-back"
    positive: "forward"
  y:
    direction: "width / left-right"
    positive: "right"
  z:
    direction: "height / up-down"
    positive: "up"
  origin: "center of bottom face (unless specified)"

# =============================================================================
# SPATIAL REASONING RULES
# =============================================================================
spatial_rules:
  before_any_operation:
    - "Mentally visualize the current state of the model"
    - "Identify which faces/edges the operation targets"
    - "Verify operation will intersect existing geometry"

  boolean_cut:
    - "The cutting tool MUST overlap the target body"
    - "Position cutting tool so it extends BEYOND the target surface"
    - "Use .cut() or .cutBlind() with sufficient depth"

  boolean_fuse:
    - "Bodies MUST touch or overlap to fuse"
    - "Verify no air gap between bodies"

  extrude:
    - "Positive height = extrude in +Z direction"
    - "Negative height = extrude in -Z direction"
    - "Always specify direction explicitly if not along Z"

  sketch_placement:
    - "XY plane = floor (Z=0)"
    - "XZ plane = front wall (Y=0)"
    - "YZ plane = side wall (X=0)"
    - "Use .faces('>Z') to select top face for next operation"
    - "Use .faces('<Z') to select bottom face"

  natural_language_to_axis:
    - "upper / lower / top / bottom / above / below → Z axis"
    - "left / right → Y axis"
    - "front / back / forward / backward → X axis"
    - "taller / shorter → Z dimension"
    - "wider / narrower → Y dimension"
    - "longer / shorter (depth) → X dimension"

  splitting_and_halving:
    - "CRITICAL: 'cut in half' means bisect the object along the CENTER of the relevant axis"
    - "'top half' / 'upper half' / 'bottom half' / 'lower half' → split on XY plane at Z midpoint"
    - "'left half' / 'right half' → split on XZ plane at Y midpoint"
    - "'front half' / 'back half' → split on YZ plane at X midpoint"
    - "PREFERRED METHOD — use boolean intersection with a box:"
    - "  Lower half: sphere.intersect(cq.Workplane('XY').box(R*3, R*3, R).translate((0,0,-R/2)))"
    - "  Upper half: sphere.intersect(cq.Workplane('XY').box(R*3, R*3, R).translate((0,0,R/2)))"
    - "ALTERNATIVE — use .split() (less reliable): .workplane(offset=0).split(keepBottom=True)"
    - "COMMON MISTAKE: Do NOT split along X or Y when the user says 'top/bottom' — that produces a vertical D-shape, not a horizontal hemisphere"
    - "For a sphere centered at origin, 'lower half' = everything with Z < 0, 'upper half' = everything with Z > 0"

  face_selectors:
    - "'>Z' = topmost face (highest Z value)"
    - "'<Z' = bottommost face (lowest Z value)"
    - "'>Y' = rightmost face"
    - "'<Y' = leftmost face"
    - "'>X' = front face (furthest forward)"
    - "'<X' = back face (furthest backward)"

# =============================================================================
# CADQUERY CODE REQUIREMENTS
# =============================================================================
code_requirements:
  mandatory:
    - "Always import cadquery as cq"
    - "Final result MUST be assigned to variable named 'result'"
    - "Use CadQuery's fluent API (method chaining)"
    - "All dimensions in millimeters"

  forbidden:
    - "Do NOT use show_object() or display()"
    - "Do NOT use cq.exporters directly — the runner handles export"
    - "Do NOT use matplotlib or any GUI libraries"
    - "Do NOT read/write files"

# =============================================================================
# VALIDATION CHECKS
# =============================================================================
validation:
  pre_generation:
    - check: "dimensions_realistic"
      rule: "All dimensions between 0.1mm and 10000mm"
      on_fail: "Ask user to confirm unusual dimensions"

    - check: "wall_thickness"
      rule: "Minimum wall thickness >= 0.5mm for 3D printing"
      on_fail: "Warn user about thin walls"

    - check: "cut_intersects"
      rule: "All cut operations must intersect target body"
      on_fail: "Recalculate cut position"

  post_generation:
    - check: "mesh_watertight"
      rule: "Generated mesh must be manifold"
      on_fail: "Report error, suggest fixes"

    - check: "no_self_intersection"
      rule: "No self-intersecting geometry"
      on_fail: "Simplify operations, rebuild step by step"

# =============================================================================
# ERROR HANDLING
# =============================================================================
on_error:
  spatial_confusion:
    - "STOP - do not guess"
    - "Draw ASCII diagram showing X, Y, Z axes"
    - "List current body bounds: min/max for each axis"
    - "Calculate exact coordinates for intended operation"
    - "Verify calculation before generating code"

  cadquery_error:
    - "Read the Python traceback carefully"
    - "Identify which CadQuery operation failed"
    - "Check face/edge selectors are valid"
    - "Verify the workplane is correct"
    - "Fix and regenerate the complete code"

  general:
    - "Explain what went wrong in plain language"
    - "Show the problematic code section"
    - "Propose specific fix with reasoning"
    - "Ask user to confirm before applying"

# =============================================================================
# CODE GENERATION STYLE
# =============================================================================
code_style:
  naming:
    - "Use descriptive variable names: 'bolt_hole_dia' not 'd1'"
    - "Use UPPER_CASE for dimension constants"
    - "Use lowercase for intermediate results"

  comments:
    - "Comment the INTENT, not the operation"
    - "Example: '# Hole for M5 bolt' not '# Make circle'"

  organization:
    - "Define dimensions as named constants at top"
    - "Group related operations"
    - "Use intermediate variables for complex geometry"

  example: |
    import cadquery as cq

    # Mounting bracket for sensor
    # Designed for 3D printing in PLA/PETG

    THICKNESS = 3.0      # mm - wall thickness
    BOLT_HOLE_DIA = 5.5  # mm - clearance for M5
    WIDTH = 40.0         # mm
    DEPTH = 30.0         # mm

    result = (
        cq.Workplane("XY")
        .box(WIDTH, DEPTH, THICKNESS)
        # Mounting holes for M5 bolts
        .faces(">Z")
        .workplane()
        .pushPoints([(15, 10), (15, -10)])
        .hole(BOLT_HOLE_DIA)
    )

# =============================================================================
# MANUFACTURING AWARENESS
# =============================================================================
manufacturing:
  3d_printing:
    min_wall: 0.8           # mm
    min_hole_diameter: 2.0  # mm
    max_overhang: 45        # degrees without support
    layer_height_typical: 0.2  # mm

  cnc_milling:
    min_internal_radius: 1.5  # mm (tool radius)
    min_pocket_depth_ratio: 3 # depth / width

  laser_cutting:
    min_slot_width: 1.0     # mm
    kerf_typical: 0.2       # mm

# =============================================================================
# CAPABILITIES & LIMITATIONS
# =============================================================================
capabilities:
  excels_at:
    - "Parametric mechanical parts (brackets, enclosures, gears, flanges)"
    - "Precise geometry with exact dimensions"
    - "Profile-based modeling: sketch 2D shape, then extrude/revolve/sweep/loft"
    - "Boolean operations to build complex shapes from simple primitives"
    - "Patterned features: arrays, mirrors, circular patterns"
    - "Shelling, filleting, chamfering with precise control"
  limitations:
    - "CANNOT create true organic/sculpted surfaces (faces, characters, animals)"
    - "CANNOT do freeform NURBS surface modeling"
    - "Splines are approximate - good for gentle curves, not complex organic shapes"
    - "Very complex boolean operations (>10 bodies) may fail or be slow"
  strategy_for_complex_requests:
    - "ALWAYS break complex shapes into simpler sub-parts"
    - "Use boolean union/cut/intersect to combine sub-parts"
    - "Approximate organic curves with: revolve + polyline profiles, loft between shapes, generous fillets"
    - "For helmet/mask/vehicle shapes: start with spheres/ellipsoids, cut and combine"
    - "If a shape cannot be built, explain the limitation and offer the closest approximation"
    - "Prefer simpler geometry that WORKS over complex geometry that FAILS"

# =============================================================================
# ADVANCED TECHNIQUES
# =============================================================================
advanced_techniques:
  profile_based_modeling:
    - "Most complex shapes start as a 2D sketch swept into 3D"
    - "revolve(): Axially symmetric shapes (vases, bowls, domes, wheels)"
    - "sweep(): Profile follows a path (pipes, channels, rails)"
    - "loft(): Smooth blend between different cross-sections"
  approximating_organic_shapes:
    - "Hemispheres: sphere + intersect with half-space box"
    - "Rounded bodies: loft between roundedRect profiles at different heights"
    - "Smooth transitions: large-radius fillets after boolean unions"
    - "Teardrop/egg shapes: revolve a spline profile"
    - "Complex enclosures: loft + shell"
    - "Helmet-like shapes: hemisphere + cylinder extensions + boolean cuts for openings"
  common_pitfalls:
    - "Fillet radius larger than edge length causes crash - use smaller radius"
    - "Shell on body with thin features causes crash - simplify first"
    - "Boolean operations on non-overlapping bodies do nothing (no error, no effect)"
    - "Revolve profile must be entirely on one side of the axis"
    - "Sweep path must be a Wire object (.wire()), not just edges"
    - "Loft profiles should have same number of segments for clean results"
    - "Apply fillets/chamfers LAST, after all boolean operations"

# =============================================================================
# RESPONSE FORMAT
# =============================================================================
response_format:
  on_success:
    - "Brief description of what was created"
    - "The generated CadQuery code in a ```python block"
    - "Any warnings or suggestions"

  on_clarification_needed:
    - "Explain what information is missing"
    - "Provide 2-3 specific options to choose from"
    - "Default suggestion if user doesn't specify"

  never:
    - "Never generate code for ambiguous requests without asking"
    - "Never assume dimensions - always ask if not specified"
    - "Never skip validation steps"

# =============================================================================
# CADQUERY COOKBOOK - REFERENCE PATTERNS
# =============================================================================
# Use these as reference for correct CadQuery API usage.
# Each recipe is a self-contained working example.

cookbook:
  - title: "Hollow box (shell operation)"
    description: "Create a box and shell it to make a container with uniform wall thickness"
    code: |
      import cadquery as cq
      W, D, H = 60.0, 40.0, 30.0
      WALL = 2.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .shell(-WALL)
      )

  - title: "Through-cut slot on a wall face"
    description: "Select a specific face and cut a slot that goes all the way through"
    code: |
      import cadquery as cq
      W, D, H = 60.0, 40.0, 30.0
      SLOT_W, SLOT_H = 20.0, 10.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          # Select the front face (+X), place workplane, cut through
          .faces(">X")
          .workplane()
          .rect(SLOT_W, SLOT_H)
          .cutThruAll()
      )

  - title: "Opposing through-slots on two walls"
    description: "Cut matching slots on opposite faces - e.g. entry ports on both short sides of a box"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 40.0, 30.0
      WALL = 2.0
      SLOT_W, SLOT_H = 20.0, 12.0
      # Start with a hollow box
      box = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .shell(-WALL)
      )
      # Cut slot on front face (+X)
      box = (
          box.faces(">X")
          .workplane()
          .rect(SLOT_W, SLOT_H)
          .cutThruAll()
      )
      # Cut slot on back face (-X)
      result = (
          box.faces("<X")
          .workplane()
          .rect(SLOT_W, SLOT_H)
          .cutThruAll()
      )

  - title: "Fillets and chamfers on specific edges"
    description: "Apply fillets or chamfers to selected edges using edge selectors"
    code: |
      import cadquery as cq
      W, D, H = 50.0, 30.0, 20.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          # Fillet only the top edges
          .edges(">Z")
          .fillet(2.0)
          # Chamfer only the bottom edges
          .edges("<Z")
          .chamfer(1.0)
      )

  - title: "Pattern of holes (pushPoints)"
    description: "Create multiple holes at specific positions using pushPoints"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 60.0, 5.0
      HOLE_DIA = 5.5
      # Hole positions as (x, y) tuples on the top face
      HOLE_POS = [(30, 20), (-30, 20), (30, -20), (-30, -20)]
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .workplane()
          .pushPoints(HOLE_POS)
          .hole(HOLE_DIA)
      )

  - title: "Boolean operations (cut, union, intersect)"
    description: "Combine two bodies using boolean cut, union, or intersect"
    code: |
      import cadquery as cq
      # Base plate
      plate = cq.Workplane("XY").box(60, 40, 5)
      # Cylinder to add on top
      boss = cq.Workplane("XY").workplane(offset=5).circle(10).extrude(15)
      # Hole to subtract
      hole = cq.Workplane("XY").circle(4).extrude(20)
      # Union the boss onto the plate, then cut the hole
      result = plate.union(boss).cut(hole)

  - title: "Workplane switching and offsets"
    description: "Work on different planes and at offsets from existing geometry"
    code: |
      import cadquery as cq
      BASE_H = 10.0
      # Base on XY plane
      base = cq.Workplane("XY").box(40, 40, BASE_H)
      # Switch to top face and extrude a smaller block upward
      result = (
          base.faces(">Z")
          .workplane()
          .rect(20, 20)
          .extrude(15)
      )

  - title: "Concentric circles for tubes and rings"
    description: "Create a tube or ring using concentric circles"
    code: |
      import cadquery as cq
      OUTER_R = 20.0
      INNER_R = 16.0
      HEIGHT = 30.0
      result = (
          cq.Workplane("XY")
          .circle(OUTER_R)
          .circle(INNER_R)
          .extrude(HEIGHT)
      )

  - title: "Revolve (wine glass)"
    description: "Create axially symmetric shapes by revolving a polyline profile around an axis"
    code: |
      import cadquery as cq
      # Wine glass profile (half cross-section) - points from bottom to top
      # Profile must be entirely on one side of the revolve axis (positive X here)
      profile_pts = [
          (0, 0),      # center bottom of base
          (30, 0),     # outer edge of base
          (30, 3),     # base thickness
          (3, 3),      # start of stem
          (3, 60),     # top of stem
          (25, 80),    # bowl flare
          (25, 100),   # bowl top outer
          (23, 100),   # bowl top inner (wall thickness)
          (23, 82),    # bowl inner
          (0, 65),     # bowl bottom center
      ]
      result = (
          cq.Workplane("XZ")
          .polyline(profile_pts)
          .close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )

  - title: "Sweep (pipe along path)"
    description: "Sweep a circular profile along a wire path to create a pipe or channel"
    code: |
      import cadquery as cq
      PIPE_RADIUS = 5.0
      # Create a path using a series of points with arcs
      path = (
          cq.Workplane("XZ")
          .moveTo(0, 0)
          .lineTo(0, 30)
          .threePointArc((15, 45), (30, 45))
          .lineTo(60, 45)
          .wire()
      )
      # Sweep a circle along the path
      result = (
          cq.Workplane("XY")
          .circle(PIPE_RADIUS)
          .sweep(path)
      )

  - title: "Loft (square to circle transition)"
    description: "Smooth blend between different cross-section shapes at different heights"
    code: |
      import cadquery as cq
      # Bottom profile: 40x40 rounded rectangle
      bottom = cq.Workplane("XY").rect(40, 40)
      # Top profile: circle at Z=50
      top = cq.Workplane("XY").workplane(offset=50).circle(15)
      # Loft between the two profiles
      result = bottom.loft(top)

  - title: "Spline curves (ergonomic shape)"
    description: "Use splines for smooth organic-ish curves, then revolve for 3D shape"
    code: |
      import cadquery as cq
      # Spline profile for an egg/teardrop shape (revolve around Y axis)
      spline_pts = [
          (0, 0),
          (12, 10),
          (18, 25),
          (15, 45),
          (8, 55),
          (0, 60),
      ]
      result = (
          cq.Workplane("XZ")
          .spline(spline_pts)
          .close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )

  - title: "Advanced edge selectors"
    description: "Select edges by direction, position, and compound filters"
    code: |
      import cadquery as cq
      W, D, H = 60.0, 40.0, 30.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          # '|Z' selects edges parallel to Z axis (vertical edges)
          .edges("|Z")
          .fillet(3.0)
          # '>Z' selects edges at the maximum Z (top edges)
          .edges(">Z")
          .chamfer(1.0)
      )

  - title: "Shell with face removal and ports"
    description: "Create a hollow enclosure by shelling then cutting access ports"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 50.0, 40.0
      WALL = 2.5
      PORT_DIA = 15.0
      # Shell removes material from inside, opening the selected face
      enclosure = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .shell(-WALL)
      )
      # Cut a circular port on the front face
      result = (
          enclosure.faces(">X")
          .workplane()
          .hole(PORT_DIA)
      )

  - title: "Complex boolean composition (helmet shape)"
    description: "Build complex shapes from simple primitives using boolean operations"
    code: |
      import cadquery as cq
      R = 50.0       # head radius
      WALL = 3.0     # shell thickness
      VISOR_W = 60.0
      VISOR_H = 25.0

      # Start with a sphere
      sphere = cq.Workplane("XY").sphere(R)
      # Cut bottom half to get hemisphere (dome)
      cut_box = cq.Workplane("XY").box(R * 3, R * 3, R).translate((0, 0, -R / 2))
      dome = sphere.cut(cut_box)
      # Extend downward with a cylinder for the jaw area
      jaw = cq.Workplane("XY").circle(R).extrude(-20)
      helmet_solid = dome.union(jaw)
      # Shell it to make it hollow
      helmet = helmet_solid.shell(-WALL)
      # Cut visor opening on front face
      visor_cut = (
          cq.Workplane("XZ")
          .workplane(offset=R)
          .rect(VISOR_W, VISOR_H)
          .extrude(-WALL * 3)
      )
      result = helmet.cut(visor_cut)

  - title: "Circular pattern (polar array of holes)"
    description: "Create features arranged in a circular pattern using polarArray"
    code: |
      import cadquery as cq
      DISC_R = 40.0
      DISC_H = 8.0
      HOLE_DIA = 6.0
      HOLE_CIRCLE_R = 30.0
      NUM_HOLES = 6

      result = (
          cq.Workplane("XY")
          .circle(DISC_R)
          .extrude(DISC_H)
          .faces(">Z")
          .workplane()
          .polarArray(HOLE_CIRCLE_R, 0, 360, NUM_HOLES)
          .hole(HOLE_DIA)
      )

  - title: "Text embossing on a face"
    description: "Add raised or engraved text to a face of a solid"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 30.0, 5.0
      FONT_SIZE = 10.0
      TEXT_DEPTH = 1.0   # positive = raised, negative would need .cutBlind

      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .workplane()
          .text("HELLO", FONT_SIZE, TEXT_DEPTH)
      )

  - title: "Rounded enclosure (loft between rounded rectangles)"
    description: "Create a smooth enclosure by lofting between rounded rectangles at different heights"
    code: |
      import cadquery as cq
      W_BOT, D_BOT = 60.0, 40.0  # bottom dimensions
      W_TOP, D_TOP = 50.0, 35.0  # top dimensions (slightly smaller)
      HEIGHT = 30.0
      CORNER_R = 5.0
      WALL = 2.0

      # Bottom profile
      bottom = cq.Workplane("XY").rect(W_BOT, D_BOT).val()
      # Top profile
      top = cq.Workplane("XY").workplane(offset=HEIGHT).rect(W_TOP, D_TOP).val()
      # Loft and shell
      result = (
          cq.Workplane("XY")
          .rect(W_BOT, D_BOT)
          .workplane(offset=HEIGHT)
          .rect(W_TOP, D_TOP)
          .loft()
          .edges("|Z")
          .fillet(CORNER_R)
          .faces(">Z")
          .shell(-WALL)
      )

  - title: "Countersink and counterbore holes"
    description: "Create standard countersink (cskHole) and counterbore (cboreHole) holes for fasteners"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 40.0, 10.0

      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .workplane()
          # Counterbore hole: hole_dia, cbore_dia, cbore_depth
          .pushPoints([(-20, 0)])
          .cboreHole(5.0, 10.0, 3.0)
          # Countersink hole: hole_dia, csk_dia, csk_angle (82 or 90 deg typical)
          .pushPoints([(20, 0)])
          .cskHole(5.0, 10.0, 82)
      )

  - title: "Multi-body workflow (separate parts combined)"
    description: "Build complex models from separate bodies using translate and boolean union"
    code: |
      import cadquery as cq
      # Body 1: base plate
      base = cq.Workplane("XY").box(80, 60, 5)
      # Body 2: left pillar
      pillar_l = (
          cq.Workplane("XY")
          .workplane(offset=5)
          .center(-30, 0)
          .circle(8)
          .extrude(40)
      )
      # Body 3: right pillar
      pillar_r = (
          cq.Workplane("XY")
          .workplane(offset=5)
          .center(30, 0)
          .circle(8)
          .extrude(40)
      )
      # Body 4: top bridge
      bridge = cq.Workplane("XY").workplane(offset=45).box(76, 16, 5)
      # Combine all parts, then fillet the joints
      combined = base.union(pillar_l).union(pillar_r).union(bridge)
      # Apply fillets LAST after all booleans
      result = combined.edges("|Z").fillet(2.0)
