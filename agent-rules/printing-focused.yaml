# CAD AI Studio - 3D Printing Focused Agent Rules
# Optimized for FDM/SLA 3D printing with strict manufacturing constraints

version: 1

# =============================================================================
# COORDINATE SYSTEM
# =============================================================================
coordinate_system:
  description: "Right-hand coordinate system"
  x:
    direction: "length / front-back"
    positive: "forward"
  y:
    direction: "width / left-right"
    positive: "right"
  z:
    direction: "height / up-down (build direction)"
    positive: "up"
  origin: "center of bottom face (print bed contact surface)"

# =============================================================================
# SPATIAL REASONING RULES
# =============================================================================
spatial_rules:
  before_any_operation:
    - "Mentally visualize the current state of the model"
    - "Identify which faces/edges the operation targets"
    - "Verify operation will intersect existing geometry"
    - "Consider print orientation - Z is the build direction"

  boolean_cut:
    - "The cutting tool MUST overlap the target body"
    - "Position cutting tool so it extends BEYOND the target surface"
    - "Use mode=Mode.SUBTRACT within the BuildPart context, or boolean subtraction"

  boolean_fuse:
    - "Bodies MUST touch or overlap to fuse"
    - "Verify no air gap between bodies"

  extrude:
    - "Positive amount = extrude in +Z direction (away from bed)"
    - "Negative amount = extrude in -Z direction (into bed)"
    - "Always specify direction explicitly if not along Z"

  sketch_placement:
    - "XY plane = print bed surface (Z=0) — Plane.XY"
    - "XZ plane = front wall (Y=0) — Plane.XZ"
    - "YZ plane = side wall (X=0) — Plane.YZ"
    - "Use part.faces().sort_by(Axis.Z)[-1] to select top face for next operation"
    - "Use part.faces().sort_by(Axis.Z)[0] to select bottom face"

  natural_language_to_axis:
    - "upper / lower / top / bottom / above / below -> Z axis (build direction)"
    - "left / right -> Y axis"
    - "front / back / forward / backward -> X axis"
    - "taller / shorter -> Z dimension"
    - "wider / narrower -> Y dimension"
    - "longer / shorter (depth) -> X dimension"

  splitting_and_halving:
    - "CRITICAL: 'cut in half' means bisect the object along the CENTER of the relevant axis"
    - "'top half' / 'upper half' / 'bottom half' / 'lower half' -> split on XY plane at Z midpoint"
    - "'left half' / 'right half' -> split on XZ plane at Y midpoint"
    - "'front half' / 'back half' -> split on YZ plane at X midpoint"
    - "PREFERRED METHOD — use boolean intersection with a box:"
    - "  Lower half: build sphere, then add Box in context with mode=Mode.INTERSECT positioned at lower half"
    - "  Upper half: build sphere, then add Box in context with mode=Mode.INTERSECT positioned at upper half"
    - "COMMON MISTAKE: Do NOT split along X or Y when the user says 'top/bottom' — that produces a vertical D-shape, not a horizontal hemisphere"
    - "For a sphere centered at origin, 'lower half' = everything with Z < 0, 'upper half' = everything with Z > 0"
    - "For 3D printing: a bowl/hemisphere (lower half) prints well flat-side-down on the bed"

  face_selectors:
    - "part.faces().sort_by(Axis.Z)[-1] = topmost face (highest Z value, furthest from bed)"
    - "part.faces().sort_by(Axis.Z)[0] = bottommost face (lowest Z value, bed contact)"
    - "part.faces().sort_by(Axis.Y)[-1] = rightmost face"
    - "part.faces().sort_by(Axis.Y)[0] = leftmost face"
    - "part.faces().sort_by(Axis.X)[-1] = front face (furthest forward)"
    - "part.faces().sort_by(Axis.X)[0] = back face (furthest backward)"

# =============================================================================
# BUILD123D CODE REQUIREMENTS
# =============================================================================
code_requirements:
  mandatory:
    - "Always use 'from build123d import *'"
    - "Final result MUST be assigned to variable named 'result'"
    - "Use Build123d's builder mode with context managers (with BuildPart() as part:)"
    - "All dimensions in millimeters"
    - "After creating a 2D sketch (BuildSketch), MUST call extrude()/revolve()/sweep()/loft() to create a 3D solid BEFORE the sketch can participate in further operations"

  forbidden:
    - "Do NOT use show_object() or display()"
    - "Do NOT use export_stl/export_step directly — the runner handles export"
    - "Do NOT use matplotlib or any GUI libraries"
    - "Do NOT read/write files"

# =============================================================================
# 3D PRINTING MANUFACTURING CONSTRAINTS
# =============================================================================
manufacturing:
  process: "3D Printing (FDM/SLA)"

  wall_thickness:
    minimum: 1.2         # mm - 3 perimeters at 0.4mm nozzle
    recommended: 1.6     # mm - 4 perimeters for strength
    rule: "All walls must be >= 1.2mm thick"
    on_violation: "Warn user and suggest increasing to at least 1.2mm"

  overhangs:
    max_angle: 45         # degrees from vertical without support
    rule: "Angles > 45 degrees from vertical require support material"
    mitigation:
      - "Add chamfers instead of sharp overhangs"
      - "Use 45-degree angles where possible"
      - "Split model if large overhangs are unavoidable"
    on_violation: "Suggest redesign to reduce overhang angle or add support-friendly geometry"

  bridging:
    max_unsupported_span: 10  # mm - typical FDM bridging limit
    rule: "Unsupported horizontal spans should not exceed 10mm"
    on_violation: "Add intermediate supports or break span into shorter segments"

  holes:
    min_diameter: 2.0     # mm - smaller holes may close up
    vertical_preferred: true
    rule: "Holes < 2mm diameter may not print cleanly"
    compensation: "Add 0.2mm to hole diameter to compensate for shrinkage"

  layer_adhesion:
    avoid_thin_vertical_features: true
    min_cross_section: 2.0  # mm^2 - minimum cross-section in XY plane
    rule: "Thin vertical features may break due to poor layer adhesion"

  bed_adhesion:
    flat_bottom_required: true
    min_contact_area: 25.0  # mm^2
    rule: "Ensure adequate flat contact area with print bed"
    on_violation: "Add a brim-compatible base or redesign bottom surface"

  tolerances:
    xy_tolerance: 0.2     # mm - typical FDM XY accuracy
    z_tolerance: 0.1      # mm - layer height dependent
    press_fit_interference: 0.1  # mm
    clearance_fit_gap: 0.3      # mm
    rule: "Design with >=0.3mm clearance for moving parts"

  supports:
    auto_detect: true
    warn_threshold: 45    # degrees
    suggest_redesign_first: true
    rule: "Always prefer redesigning to eliminate supports over adding them"

# =============================================================================
# VALIDATION CHECKS
# =============================================================================
validation:
  pre_generation:
    - check: "dimensions_realistic"
      rule: "All dimensions between 0.1mm and 500mm (typical print volume)"
      on_fail: "Warn about print bed size limitations"

    - check: "wall_thickness"
      rule: "All walls >= 1.2mm thick"
      on_fail: "Flag thin walls and suggest minimum 1.2mm"

    - check: "overhang_angles"
      rule: "No unsupported overhangs > 45 degrees"
      on_fail: "Suggest chamfers or orientation change"

    - check: "cut_intersects"
      rule: "All cut operations must intersect target body"
      on_fail: "Recalculate cut position"

    - check: "flat_bottom"
      rule: "Model should have a flat surface for bed contact"
      on_fail: "Suggest adding a flat base"

  post_generation:
    - check: "mesh_watertight"
      rule: "Generated mesh must be manifold (watertight)"
      on_fail: "Report error, suggest fixes"

    - check: "no_self_intersection"
      rule: "No self-intersecting geometry"
      on_fail: "Simplify operations, rebuild step by step"

# =============================================================================
# ERROR HANDLING
# =============================================================================
on_error:
  spatial_confusion:
    - "STOP - do not guess"
    - "Draw ASCII diagram showing X, Y, Z axes"
    - "List current body bounds: min/max for each axis"
    - "Calculate exact coordinates for intended operation"
    - "Verify calculation before generating code"

  build123d_error:
    - "Read the Python traceback carefully"
    - "Identify which Build123d operation failed"
    - "Check face/edge selectors are valid"
    - "Verify the sketch plane is correct"
    - "Fix and regenerate the complete code"

  general:
    - "Explain what went wrong in plain language"
    - "Show the problematic code section"
    - "Propose specific fix with reasoning"
    - "Ask user to confirm before applying"

# =============================================================================
# CODE GENERATION STYLE
# =============================================================================
code_style:
  naming:
    - "Use descriptive variable names: 'bolt_hole_dia' not 'd1'"
    - "Use UPPER_CASE for dimension constants"
    - "Use lowercase for intermediate results"

  comments:
    - "Comment the INTENT, not the operation"
    - "Include print orientation notes"
    - "Note any areas that may need supports"

  organization:
    - "Define dimensions as named constants at top"
    - "Group related operations"
    - "Use intermediate variables for complex geometry"
    - "Add wall thickness as a named constant"

  example: |
    from build123d import *

    # Phone stand - designed for FDM 3D printing
    # Print orientation: upright (base on print bed)
    # No supports needed with 45-degree back angle

    WALL = 2.0            # mm - wall thickness (5 perimeters)
    BASE_W = 70.0         # mm - base width
    BASE_D = 50.0         # mm - base depth
    BASE_H = 5.0          # mm - base height

    with BuildPart() as part:
        Box(BASE_W, BASE_D, BASE_H)
        # Hollow out the base, keeping flat bottom for bed adhesion
        with Locations((0, 0, WALL / 2)):
            Box(BASE_W - 2 * WALL, BASE_D - 2 * WALL, BASE_H - WALL, mode=Mode.SUBTRACT)
    result = part.part

# =============================================================================
# CAPABILITIES & LIMITATIONS
# =============================================================================
capabilities:
  excels_at:
    - "Parametric mechanical parts (brackets, enclosures, gears, flanges)"
    - "Precise geometry with exact dimensions"
    - "Profile-based modeling: sketch 2D shape, then extrude/revolve/sweep/loft"
    - "Boolean operations to build complex shapes from simple primitives"
    - "Patterned features: GridLocations, PolarLocations, mirrors"
    - "Filleting, chamfering with precise control; hollowing via boolean subtraction"
    - "Print-ready models with flat bases and minimal overhangs"
  limitations:
    - "CANNOT create true organic/sculpted surfaces (faces, characters, animals)"
    - "CANNOT do freeform NURBS surface modeling"
    - "Splines are approximate - good for gentle curves, not complex organic shapes"
    - "Very complex boolean operations (>10 bodies) may fail or be slow"
  strategy_for_complex_requests:
    - "ALWAYS break complex shapes into simpler sub-parts"
    - "Use boolean union/cut/intersect to combine sub-parts (mode=Mode.ADD/SUBTRACT/INTERSECT)"
    - "Approximate organic curves with: revolve + polyline profiles, loft between shapes, generous fillets"
    - "For helmet/mask/vehicle shapes: start with spheres/ellipsoids, cut and combine"
    - "If a shape cannot be built, explain the limitation and offer the closest approximation"
    - "Prefer simpler geometry that WORKS over complex geometry that FAILS"
    - "Consider print orientation when designing - minimize overhangs and supports"

# =============================================================================
# ADVANCED TECHNIQUES
# =============================================================================
advanced_techniques:
  profile_based_modeling:
    - "Most complex shapes start as a 2D sketch swept into 3D"
    - "revolve(): Axially symmetric shapes (vases, bowls, domes, wheels)"
    - "sweep(): Profile follows a path (pipes, channels, rails)"
    - "loft(): Smooth blend between different cross-sections"
  approximating_organic_shapes:
    - "Hemispheres: sphere + intersect with half-space box using Mode.INTERSECT"
    - "Rounded bodies: loft between RectangleRounded profiles at different heights"
    - "Smooth transitions: large-radius fillets after boolean unions"
    - "Teardrop/egg shapes: revolve a spline profile"
    - "Complex enclosures: loft outer + loft inner + boolean subtract"
    - "Helmet-like shapes: hemisphere + cylinder extensions + boolean cuts for openings"
  print_specific_techniques:
    - "Design flat bases for bed adhesion"
    - "Use 45-degree chamfers instead of sharp overhangs"
    - "Split tall models into interlocking parts if they exceed build volume"
    - "Add draft angles to vertical walls for easier support removal"
  common_pitfalls:
    - "Fillet radius larger than edge length causes crash - use smaller radius"
    - "Do NOT use offset_3d() on complex geometry — create inner solid and use Mode.SUBTRACT to hollow"
    - "Boolean operations on non-overlapping bodies do nothing (no error, no effect)"
    - "Revolve profile must be entirely on one side of the axis"
    - "Sweep path must be a valid wire/edge chain"
    - "Loft profiles should have same number of segments for clean results"
    - "Apply fillets/chamfers LAST, after all boolean operations"
    - "Shell wall thickness must be >= 1.2mm for printability"

# =============================================================================
# DESIGN THINKING (mandatory pre-generation reasoning)
# =============================================================================
design_thinking:
  mandatory_before_code:
    - "Before writing ANY code, describe the object's geometry in plain English"
    - "List each geometric feature and what Build123d operation implements it"
    - "Specify approximate dimensions and positions for each feature"
    - "Plan the build sequence (what order to apply operations)"
    - "Identify the base shape that everything else builds upon"

  for_organic_shapes:
    - "Describe the cross-section profile at multiple heights (bottom, middle, top)"
    - "Use revolve() with spline/polyline profiles for axially symmetric parts"
    - "Use loft() between profiles at different heights for varying shapes"
    - "Apply generous fillets (3-8mm) to smooth sharp boolean transitions"
    - "Accept approximation — describe what the closest buildable shape is"
    - "For helmet/mask shapes: use loft between oval profiles, NOT just a sphere with cuts"

  for_complex_objects:
    - "Decompose into major sub-assemblies first (e.g. body, lid, handle)"
    - "For each sub-assembly, identify the base shape and modifications"
    - "Plan boolean operations: which parts get unioned, which get cut"
    - "Verify each cut tool overlaps the target before writing code"
    - "Think about what makes the object RECOGNIZABLE and prioritize those features"

# =============================================================================
# RESPONSE FORMAT
# =============================================================================
response_format:
  on_success:
    - "Brief description of what was created"
    - "The generated Build123d code wrapped in <CODE>...</CODE> tags"
    - "Print orientation recommendation"
    - "Any areas that may need supports"
    - "Estimated print time range (if applicable)"

  on_clarification_needed:
    - "Explain what information is missing"
    - "Provide 2-3 specific options to choose from"
    - "Default suggestion optimized for 3D printing"

  never:
    - "Never generate code for ambiguous requests without asking"
    - "For custom/abstract parts, ask for dimensions if not specified. For real-world objects, use typical dimensions and state your assumptions"
    - "Never skip printability validation"
    - "Never create geometry with walls thinner than 1.2mm without warning"

# =============================================================================
# BUILD123D COOKBOOK - REFERENCE PATTERNS
# =============================================================================
# Use these as reference for correct Build123d API usage.
# Each recipe is a self-contained working example.

cookbook:
  - title: "Hollow box (boolean subtraction)"
    description: "Create a hollow container by subtracting an inner solid from an outer solid"
    code: |
      from build123d import *
      W, D, H = 60.0, 40.0, 30.0
      WALL = 2.0
      with BuildPart() as part:
          Box(W, D, H)
          with Locations((0, 0, WALL / 2)):
              Box(W - 2*WALL, D - 2*WALL, H - WALL, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Through-cut slot on a wall face"
    description: "Select a specific face and cut a slot that goes all the way through"
    code: |
      from build123d import *
      W, D, H = 60.0, 40.0, 30.0
      SLOT_W, SLOT_H = 20.0, 10.0
      with BuildPart() as part:
          Box(W, D, H)
          # Select the front face (+X), sketch on it, cut through
          with BuildSketch(part.faces().sort_by(Axis.X)[-1]):
              Rectangle(SLOT_W, SLOT_H)
          extrude(amount=-D, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Opposing through-slots on two walls"
    description: "Cut matching slots on opposite faces - e.g. entry ports on both short sides of a box"
    code: |
      from build123d import *
      W, D, H = 80.0, 40.0, 30.0
      WALL = 2.0
      SLOT_W, SLOT_H = 20.0, 12.0
      with BuildPart() as part:
          # Start with a hollow box
          Box(W, D, H)
          offset_3d(openings=part.faces().sort_by(Axis.Z)[-1], amount=-WALL)
          # Cut slot on front face (+X)
          with BuildSketch(part.faces().sort_by(Axis.X)[-1]):
              Rectangle(SLOT_W, SLOT_H)
          extrude(amount=-WALL * 2, mode=Mode.SUBTRACT)
          # Cut slot on back face (-X)
          with BuildSketch(part.faces().sort_by(Axis.X)[0]):
              Rectangle(SLOT_W, SLOT_H)
          extrude(amount=-WALL * 2, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Fillets and chamfers on specific edges"
    description: "Apply fillets or chamfers to selected edges using edge selectors"
    code: |
      from build123d import *
      W, D, H = 50.0, 30.0, 20.0
      with BuildPart() as part:
          Box(W, D, H)
          # Fillet only the top edges
          fillet(part.edges().sort_by(Axis.Z)[-4:], radius=2.0)
          # Chamfer only the bottom edges
          chamfer(part.edges().sort_by(Axis.Z)[:4], length=1.0)
      result = part.part

  - title: "Pattern of holes (Locations)"
    description: "Create multiple holes at specific positions using Locations"
    code: |
      from build123d import *
      W, D, H = 80.0, 60.0, 5.0
      HOLE_DIA = 5.5
      # Hole positions as (x, y) tuples on the top face
      HOLE_POS = [(30, 20), (-30, 20), (30, -20), (-30, -20)]
      with BuildPart() as part:
          Box(W, D, H)
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):
              with Locations(HOLE_POS):
                  Circle(HOLE_DIA / 2)
          extrude(amount=-H, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Boolean operations (Mode.ADD, Mode.SUBTRACT, Mode.INTERSECT)"
    description: "Combine bodies using boolean add, subtract, or intersect"
    code: |
      from build123d import *
      with BuildPart() as part:
          # Base plate
          Box(60, 40, 5)
          # Cylinder to add on top
          with Locations((0, 0, 5)):
              Cylinder(radius=10, height=15)
          # Hole to subtract
          Cylinder(radius=4, height=25, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Sketch on different planes and offsets"
    description: "Work on different planes and at offsets from existing geometry"
    code: |
      from build123d import *
      BASE_H = 10.0
      with BuildPart() as part:
          # Base on XY plane
          Box(40, 40, BASE_H)
          # Switch to top face and extrude a smaller block upward
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):
              Rectangle(20, 20)
          extrude(amount=15)
      result = part.part

  - title: "Tube / ring (concentric cylinders)"
    description: "Create a tube or ring using concentric cylinders with subtraction"
    code: |
      from build123d import *
      OUTER_R = 20.0
      INNER_R = 16.0
      HEIGHT = 30.0
      with BuildPart() as part:
          Cylinder(radius=OUTER_R, height=HEIGHT)
          Cylinder(radius=INNER_R, height=HEIGHT, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Revolve (wine glass)"
    description: "Create axially symmetric shapes by revolving a polyline profile around an axis"
    code: |
      from build123d import *
      # Wine glass profile (half cross-section) - points from bottom to top
      # Profile must be entirely on one side of the revolve axis (positive X here)
      profile_pts = [
          (0, 0),      # center bottom of base
          (30, 0),     # outer edge of base
          (30, 3),     # base thickness
          (3, 3),      # start of stem
          (3, 60),     # top of stem
          (25, 80),    # bowl flare
          (25, 100),   # bowl top outer
          (23, 100),   # bowl top inner (wall thickness)
          (23, 82),    # bowl inner
          (0, 65),     # bowl bottom center
      ]
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(profile_pts)
                  Line(profile_pts[-1], profile_pts[0])
              make_face()
          revolve(axis=Axis.Z)
      result = part.part

  - title: "Sweep (pipe along path)"
    description: "Sweep a circular profile along a wire path to create a pipe or channel"
    code: |
      from build123d import *
      PIPE_RADIUS = 5.0
      with BuildPart() as part:
          # Create a path
          with BuildLine() as path:
              Line((0, 0, 0), (0, 0, 30))
              RadiusArc((0, 0, 30), (30, 0, 45), radius=15)
              Line((30, 0, 45), (60, 0, 45))
          # Create profile perpendicular to path start
          with BuildSketch(Plane(origin=path.line @ 0, z_dir=path.line % 0)) as profile:
              Circle(PIPE_RADIUS)
          sweep()
      result = part.part

  - title: "Loft (square to circle transition)"
    description: "Smooth blend between different cross-section shapes at different heights"
    code: |
      from build123d import *
      with BuildPart() as part:
          # Bottom profile: 40x40 rectangle
          with BuildSketch() as sk1:
              Rectangle(40, 40)
          # Top profile: circle at Z=50
          with BuildSketch(Plane.XY.offset(50)) as sk2:
              Circle(15)
          loft()
      result = part.part

  - title: "Spline curves (ergonomic shape)"
    description: "Use splines for smooth organic-ish curves, then revolve for 3D shape"
    code: |
      from build123d import *
      # Spline profile for an egg/teardrop shape (revolve around Z axis)
      spline_pts = [
          (0, 0),
          (12, 10),
          (18, 25),
          (15, 45),
          (8, 55),
          (0, 60),
      ]
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Spline(spline_pts)
                  Line(spline_pts[-1], spline_pts[0])
              make_face()
          revolve(axis=Axis.Z)
      result = part.part

  - title: "Advanced edge selectors"
    description: "Select edges by direction, position, and filtering"
    code: |
      from build123d import *
      W, D, H = 60.0, 40.0, 30.0
      with BuildPart() as part:
          Box(W, D, H)
          # Filter edges parallel to Z axis (vertical edges)
          fillet(part.edges().filter_by(Axis.Z), radius=3.0)
          # Select edges at the maximum Z (top edges)
          chamfer(part.edges().sort_by(Axis.Z)[-4:], length=1.0)
      result = part.part

  - title: "Hollow enclosure with port (boolean subtraction)"
    description: "Create a hollow enclosure by boolean subtraction then cut access port"
    code: |
      from build123d import *
      W, D, H = 80.0, 50.0, 40.0
      WALL = 2.5
      PORT_DIA = 15.0
      with BuildPart() as part:
          # Create outer box and hollow it
          Box(W, D, H)
          with Locations((0, 0, WALL / 2)):
              Box(W - 2*WALL, D - 2*WALL, H - WALL, mode=Mode.SUBTRACT)
          # Cut a circular port on the front face (+X)
          with BuildSketch(part.faces().sort_by(Axis.X)[-1]):
              Circle(PORT_DIA / 2)
          extrude(amount=-WALL * 2, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Complex boolean composition (helmet shape)"
    description: "Build complex shapes from simple primitives using boolean operations"
    code: |
      from build123d import *
      R = 50.0       # head radius
      WALL = 3.0     # shell thickness
      VISOR_W = 60.0
      VISOR_H = 25.0

      # Build outer shell
      with BuildPart() as part:
          # Start with a sphere
          Sphere(R)
          # Cut bottom half to get hemisphere (dome)
          with Locations((0, 0, -R / 2)):
              Box(R * 3, R * 3, R, mode=Mode.SUBTRACT)
          # Extend downward with a cylinder for the jaw area
          Cylinder(radius=R, height=20, align=(Align.CENTER, Align.CENTER, Align.MAX))
          # Hollow it out
          Sphere(R - WALL, mode=Mode.SUBTRACT)
          Cylinder(radius=R - WALL, height=25, align=(Align.CENTER, Align.CENTER, Align.MAX), mode=Mode.SUBTRACT)
          # Cut visor opening on front face
          with Locations((0, R, R * 0.3)):
              Box(VISOR_W, WALL * 6, VISOR_H, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Circular pattern (polar array of holes)"
    description: "Create features arranged in a circular pattern using PolarLocations"
    code: |
      from build123d import *
      DISC_R = 40.0
      DISC_H = 8.0
      HOLE_DIA = 6.0
      HOLE_CIRCLE_R = 30.0
      NUM_HOLES = 6

      with BuildPart() as part:
          Cylinder(radius=DISC_R, height=DISC_H)
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):
              with PolarLocations(HOLE_CIRCLE_R, NUM_HOLES):
                  Circle(HOLE_DIA / 2)
          extrude(amount=-DISC_H, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Text embossing on a face"
    description: "Add raised or engraved text to a face of a solid"
    code: |
      from build123d import *
      W, D, H = 80.0, 30.0, 5.0
      FONT_SIZE = 10.0
      TEXT_DEPTH = 1.0

      with BuildPart() as part:
          Box(W, D, H)
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):
              Text("HELLO", font_size=FONT_SIZE)
          extrude(amount=TEXT_DEPTH)
      result = part.part

  - title: "Rounded enclosure (loft between rectangles)"
    description: "Create a smooth enclosure by lofting between rectangles at different heights"
    code: |
      from build123d import *
      W_BOT, D_BOT = 60.0, 40.0
      W_TOP, D_TOP = 50.0, 35.0
      HEIGHT = 30.0
      CORNER_R = 5.0
      WALL = 2.0

      with BuildPart() as part:
          # Bottom profile
          with BuildSketch() as sk1:
              Rectangle(W_BOT, D_BOT)
          # Top profile
          with BuildSketch(Plane.XY.offset(HEIGHT)) as sk2:
              Rectangle(W_TOP, D_TOP)
          loft()
          fillet(part.edges().filter_by(Axis.Z), radius=CORNER_R)
          # Hollow via subtraction
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):
              offset(amount=-WALL)
          extrude(amount=-(HEIGHT - WALL), mode=Mode.SUBTRACT)
      result = part.part

  - title: "Counterbore and countersink holes"
    description: "Create standard counterbore and countersink holes for fasteners"
    code: |
      from build123d import *
      W, D, H = 80.0, 40.0, 10.0

      with BuildPart() as part:
          Box(W, D, H)
          # Counterbore hole at (-20, 0)
          with Locations((-20, 0)):
              CounterBoreHole(radius=2.5, counter_bore_radius=5.0, counter_bore_depth=3.0, depth=H)
          # Countersink hole at (20, 0)
          with Locations((20, 0)):
              CounterSinkHole(radius=2.5, counter_sink_radius=5.0, depth=H)
      result = part.part

  - title: "Multi-body workflow (separate parts combined)"
    description: "Build complex models from separate bodies combined into one"
    code: |
      from build123d import *
      with BuildPart() as part:
          # Base plate
          Box(80, 60, 5)
          # Left pillar
          with Locations((-30, 0, 5)):
              Cylinder(radius=8, height=40, align=(Align.CENTER, Align.CENTER, Align.MIN))
          # Right pillar
          with Locations((30, 0, 5)):
              Cylinder(radius=8, height=40, align=(Align.CENTER, Align.CENTER, Align.MIN))
          # Top bridge
          with Locations((0, 0, 47.5)):
              Box(76, 16, 5)
          # Apply fillets LAST after all geometry
          fillet(part.edges().filter_by(Axis.Z), radius=2.0)
      result = part.part

  - title: "Helmet shape via multi-height loft + boolean cuts"
    description: "Build a helmet-like shape by lofting between oval profiles at different heights, then cutting visor and mouth openings."
    code: |
      from build123d import *

      H_WIDTH = 180.0
      H_DEPTH = 220.0
      H_HEIGHT = 200.0
      WALL = 4.0

      with BuildPart() as part:
          # Outer shell by lofting oval profiles at different heights
          with BuildSketch() as sk1:
              Ellipse(H_WIDTH / 2, H_DEPTH / 2)
          with BuildSketch(Plane.XY.offset(H_HEIGHT * 0.4)) as sk2:
              Ellipse(H_WIDTH / 2 * 1.05, H_DEPTH / 2 * 1.05)
          with BuildSketch(Plane.XY.offset(H_HEIGHT * 0.75)) as sk3:
              Ellipse(H_WIDTH / 2 * 0.85, H_DEPTH / 2 * 0.9)
          with BuildSketch(Plane.XY.offset(H_HEIGHT)) as sk4:
              Ellipse(H_WIDTH / 2 * 0.4, H_DEPTH / 2 * 0.5)
          loft()
          # Hollow via offset_3d (open at bottom)
          offset_3d(openings=part.faces().sort_by(Axis.Z)[0], amount=-WALL)
          # Cut visor opening
          VISOR_W = 140.0
          VISOR_H = 40.0
          VISOR_Z = H_HEIGHT * 0.55
          with Locations((0, H_DEPTH / 2, VISOR_Z)):
              Box(VISOR_W, WALL * 6, VISOR_H, mode=Mode.SUBTRACT)
          # Cut mouth vent
          MOUTH_W = 60.0
          MOUTH_H = 15.0
          MOUTH_Z = H_HEIGHT * 0.3
          with Locations((0, H_DEPTH / 2, MOUTH_Z)):
              Box(MOUTH_W, WALL * 6, MOUTH_H, mode=Mode.SUBTRACT)
      try:
          fillet(part.edges(), radius=2.0)
      except Exception:
          pass
      result = part.part

  - title: "Ergonomic handle via revolve with spline profile"
    description: "Create a grip/handle shape using revolve with a spline profile curve."
    code: |
      from build123d import *

      PROFILE_PTS = [
          (0, 0), (12, 0), (14, 10), (16, 30), (15, 50),
          (12, 70), (8, 90), (10, 100), (10, 105), (0, 105),
      ]

      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Spline(PROFILE_PTS)
                  Line(PROFILE_PTS[-1], PROFILE_PTS[0])
              make_face()
          revolve(axis=Axis.Z)
      result = part.part

  - title: "Phone case using loft + boolean cuts for ports"
    description: "Build a phone case shape by lofting rectangles, hollowing, then cutting openings."
    code: |
      from build123d import *

      PH_W = 75.0
      PH_D = 155.0
      PH_T = 10.0
      WALL = 1.5
      CORNER_R = 8.0

      with BuildPart() as part:
          with BuildSketch() as sk1:
              Rectangle(PH_W, PH_D)
          with BuildSketch(Plane.XY.offset(PH_T)) as sk2:
              Rectangle(PH_W + 1.0, PH_D + 1.0)
          loft()
          fillet(part.edges().filter_by(Axis.Z), radius=CORNER_R)
          # Hollow from top (screen side)
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):
              offset(amount=-WALL)
          extrude(amount=-(PH_T - WALL), mode=Mode.SUBTRACT)
          # Cut camera hole on back
          CAM_X = -PH_W / 2 + 20.0
          CAM_Y = PH_D / 2 - 25.0
          with Locations((CAM_X, CAM_Y, 0)):
              Box(30.0, 35.0, WALL * 4, mode=Mode.SUBTRACT)
          # Cut charging port on bottom edge
          with Locations((0, -PH_D / 2, PH_T / 2)):
              Box(15.0, WALL * 4, 5.0, mode=Mode.SUBTRACT)
      result = part.part

  # --- Phase 1.1: Expanded Recipes (25 new) ---

  # A. Plumbing & Fluid

  - title: "Pipe elbow (90-degree swept bend)"
    description: "Sweep a circular profile along a 90-degree arc to create a pipe elbow"
    code: |
      from build123d import *
      PIPE_OD = 20.0
      PIPE_WALL = 2.0
      BEND_R = 40.0

      with BuildPart() as part:
          # Outer pipe
          with BuildLine() as path:
              RadiusArc((0, 0, 0), (BEND_R, 0, BEND_R), radius=BEND_R)
          with BuildSketch(Plane(origin=path.line @ 0, z_dir=path.line % 0)):
              Circle(PIPE_OD / 2)
          sweep()
          # Inner void
          with BuildLine() as path2:
              RadiusArc((0, 0, 0), (BEND_R, 0, BEND_R), radius=BEND_R)
          with BuildSketch(Plane(origin=path2.line @ 0, z_dir=path2.line % 0)):
              Circle(PIPE_OD / 2 - PIPE_WALL)
          sweep(mode=Mode.SUBTRACT)
      result = part.part

  - title: "Pipe T-junction"
    description: "Create a hollow T-junction from outer and inner cylinder booleans"
    code: |
      from build123d import *
      OD = 20.0
      WALL = 2.0
      ID = OD - 2 * WALL
      LENGTH = 60.0
      BRANCH_L = 40.0
      with BuildPart() as part:
          # Outer solid T-shape
          Cylinder(radius=OD / 2, height=LENGTH)
          with Locations((0, 0, 0)):
              Cylinder(radius=OD / 2, height=BRANCH_L,
                       rotation=(90, 0, 0),
                       align=(Align.CENTER, Align.CENTER, Align.MIN))
          # Inner void T-shape
          Cylinder(radius=ID / 2, height=LENGTH + 2, mode=Mode.SUBTRACT)
          with Locations((0, 0, 0)):
              Cylinder(radius=ID / 2, height=BRANCH_L + 1,
                       rotation=(90, 0, 0),
                       align=(Align.CENTER, Align.CENTER, Align.MIN),
                       mode=Mode.SUBTRACT)
      result = part.part

  # B. Fasteners & Hardware

  - title: "Hex bolt (simplified, no threads)"
    description: "Hex head polygon extruded + cylindrical shaft with chamfered tip."
    code: |
      from build123d import *
      HEAD_AF = 13.0   # across-flats (wrench size)
      HEAD_H = 5.3
      SHAFT_D = 8.0
      SHAFT_L = 30.0
      with BuildPart() as part:
          # Hex head
          with BuildSketch() as sk:
              RegularPolygon(radius=HEAD_AF / 2, side_count=6, major_radius=False)
          extrude(amount=HEAD_H)
          # Shaft below head
          with Locations((0, 0, 0)):
              Cylinder(radius=SHAFT_D / 2, height=SHAFT_L,
                       align=(Align.CENTER, Align.CENTER, Align.MAX))
          # Chamfer bottom edges
          chamfer(part.edges().sort_by(Axis.Z)[:4], length=0.8)
      result = part.part

  - title: "Standoff / spacer with hex base"
    description: "Hex base polygon + hollow cylindrical body + through-hole for a screw"
    code: |
      from build123d import *
      HEX_AF = 8.0     # across-flats
      HEX_H = 3.0
      BODY_OD = 6.0
      BODY_H = 10.0
      BORE_D = 3.2     # M3 clearance
      with BuildPart() as part:
          # Hex base
          with BuildSketch() as sk:
              RegularPolygon(radius=HEX_AF / 2, side_count=6, major_radius=False)
          extrude(amount=HEX_H)
          # Round body on top
          with Locations((0, 0, HEX_H)):
              Cylinder(radius=BODY_OD / 2, height=BODY_H,
                       align=(Align.CENTER, Align.CENTER, Align.MIN))
          # Through-hole
          Cylinder(radius=BORE_D / 2, height=HEX_H + BODY_H + 1, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Bearing seat (revolved stepped bore)"
    description: "Revolve a stepped bore profile with shoulder and snap-ring groove for a bearing housing"
    code: |
      from build123d import *
      pts = [
          (0, 0), (20, 0), (20, 5),
          (16, 5), (16, 8),
          (11, 8), (11, 25),
          (12, 25), (12, 27), (11, 27),
          (11, 30), (20, 30), (20, 35),
          (0, 35),
      ]
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(pts)
                  Line(pts[-1], pts[0])
              make_face()
          revolve(axis=Axis.Z)
      result = part.part

  # C. Joints & Connections

  - title: "Snap-fit hook (cantilever with barb)"
    description: "A cantilever arm with an angled barb tip, extruded from a polyline profile"
    code: |
      from build123d import *
      ARM_L = 15.0
      ARM_T = 1.5
      ARM_W = 5.0
      BARB_H = 2.0
      BARB_ANGLE_RUN = 1.5
      BASE_H = 5.0
      pts = [
          (0, 0), (ARM_T, 0), (ARM_T, BASE_H),
          (ARM_T, BASE_H + ARM_L),
          (ARM_T + BARB_ANGLE_RUN, BASE_H + ARM_L + BARB_H),
          (ARM_T, BASE_H + ARM_L + BARB_H),
          (0, BASE_H + ARM_L + BARB_H),
          (0, BASE_H),
      ]
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(pts)
                  Line(pts[-1], pts[0])
              make_face()
          extrude(amount=ARM_W)
      result = part.part

  - title: "Dovetail joint (male and female pieces)"
    description: "Trapezoidal male dovetail piece and matching female block with trapezoidal cutout"
    code: |
      from build123d import *
      BASE_W = 10.0
      TOP_W = 14.0
      DT_H = 8.0
      LENGTH = 40.0
      BLOCK = 30.0
      tail_pts = [
          (-BASE_W / 2, 0), (BASE_W / 2, 0),
          (TOP_W / 2, DT_H), (-TOP_W / 2, DT_H),
      ]
      # Male dovetail piece
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(tail_pts)
                  Line(tail_pts[-1], tail_pts[0])
              make_face()
          extrude(amount=LENGTH)
      result = part.part

  # D. Brackets & Structural

  - title: "L-bracket with gusset and mounting holes"
    description: "L-profile from polyline extrude, triangular gusset for stiffness, and mounting holes"
    code: |
      from build123d import *
      W = 40.0
      LEG = 50.0
      T = 4.0
      HOLE_D = 5.5
      l_pts = [
          (0, 0), (LEG, 0), (LEG, T),
          (T, T), (T, LEG), (0, LEG),
      ]
      with BuildPart() as part:
          # L-profile
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(l_pts)
                  Line(l_pts[-1], l_pts[0])
              make_face()
          extrude(amount=W)
          # Triangular gusset
          gusset_pts = [(T, T), (T + 15, T), (T, T + 15)]
          with BuildSketch(Plane.XZ.offset(W * 0.35)) as sk2:
              with BuildLine() as ln2:
                  Polyline(gusset_pts)
                  Line(gusset_pts[-1], gusset_pts[0])
              make_face()
          extrude(amount=W * 0.3)
          # Mounting holes on horizontal leg
          with BuildSketch(part.faces().sort_by(Axis.Z)[0]):
              with Locations([(20, W / 2 - 10), (40, W / 2 - 10)]):
                  Circle(HOLE_D / 2)
          extrude(amount=-T, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Shelf bracket (triangular plate with fillet)"
    description: "Triangular bracket plate from polyline profile with fillet and two mounting holes"
    code: |
      from build123d import *
      ARM_H = 80.0
      ARM_W = 60.0
      T = 5.0
      HOLE_D = 6.0
      FILLET_R = 15.0
      pts = [(0, 0), (ARM_W, 0), (0, ARM_H)]
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(pts)
                  Line(pts[-1], pts[0])
              make_face()
          extrude(amount=T)
          # Fillet the hypotenuse
          edges_y = part.edges().filter_by(Axis.Y)
          if len(edges_y) > 0:
              fillet(edges_y, radius=FILLET_R)
      result = part.part

  # E. Enclosures & Cases

  - title: "Electronics enclosure with standoffs"
    description: "Rectangular box with hollow interior, corner standoff cylinders, and screw holes"
    code: |
      from build123d import *
      W, D, H = 80.0, 60.0, 30.0
      WALL = 2.0
      STANDOFF_D = 6.0
      STANDOFF_H = 5.0
      SCREW_D = 2.5
      INSET = 6.0
      corners = [
          (W / 2 - INSET, D / 2 - INSET),
          (-W / 2 + INSET, D / 2 - INSET),
          (W / 2 - INSET, -D / 2 + INSET),
          (-W / 2 + INSET, -D / 2 + INSET),
      ]
      with BuildPart() as part:
          # Outer shell
          Box(W, D, H)
          with Locations((0, 0, WALL / 2)):
              Box(W - 2*WALL, D - 2*WALL, H - WALL, mode=Mode.SUBTRACT)
          # Corner standoffs
          for cx, cy in corners:
              with Locations((cx, cy, -H/2 + WALL)):
                  Cylinder(radius=STANDOFF_D / 2, height=STANDOFF_H,
                           align=(Align.CENTER, Align.CENTER, Align.MIN))
          # Screw holes through standoffs
          for cx, cy in corners:
              with Locations((cx, cy, 0)):
                  Hole(radius=SCREW_D / 2, depth=H)
      result = part.part

  # F. Rotational Parts

  - title: "Spur gear (simplified involute)"
    description: "Simplified spur gear with 12 teeth using polyline tooth profile, plus center bore"
    code: |
      from build123d import *
      import math
      N_TEETH = 12
      MODULE = 2.5
      FACE_W = 8.0
      BORE_D = 10.0
      PD = MODULE * N_TEETH
      OD = PD + 2 * MODULE
      RD = PD - 2.5 * MODULE
      TOOTH_ARC = 360.0 / N_TEETH
      HALF_T = TOOTH_ARC / 4
      r_root = RD / 2
      r_tip = OD / 2
      a = math.radians(HALF_T)
      tooth_pts = [
          (r_root * math.cos(-a * 1.2), r_root * math.sin(-a * 1.2)),
          (r_tip * math.cos(-a * 0.4), r_tip * math.sin(-a * 0.4)),
          (r_tip * math.cos(a * 0.4), r_tip * math.sin(a * 0.4)),
          (r_root * math.cos(a * 1.2), r_root * math.sin(a * 1.2)),
      ]
      with BuildPart() as part:
          # Root circle disc
          Cylinder(radius=r_root, height=FACE_W)
          # Add teeth
          for i in range(N_TEETH):
              angle = i * TOOTH_ARC
              cos_a = math.cos(math.radians(angle))
              sin_a = math.sin(math.radians(angle))
              rotated = [(x * cos_a - y * sin_a, x * sin_a + y * cos_a) for x, y in tooth_pts]
              with BuildSketch() as tsk:
                  with BuildLine() as tln:
                      Polyline(rotated)
                      Line(rotated[-1], rotated[0])
                  make_face()
              extrude(amount=FACE_W)
          # Center bore
          Hole(radius=BORE_D / 2, depth=FACE_W)
      result = part.part

  - title: "Pulley wheel (revolve with V-groove)"
    description: "Revolve a profile with a V-groove to create a pulley wheel with center bore"
    code: |
      from build123d import *
      OD = 50.0
      W = 15.0
      GROOVE_D = 8.0
      BORE_D = 10.0
      pts = [
          (BORE_D / 2, 0), (OD / 2, 0), (OD / 2, W * 0.3),
          (OD / 2 - GROOVE_D, W / 2),
          (OD / 2, W * 0.7), (OD / 2, W),
          (BORE_D / 2, W),
      ]
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(pts)
                  Line(pts[-1], pts[0])
              make_face()
          revolve(axis=Axis.Z)
          Hole(radius=BORE_D / 2, depth=W + 1)
      result = part.part

  - title: "Cam profile (eccentric disc)"
    description: "Create an eccentric disc cam with shaft bore"
    code: |
      from build123d import *
      CAM_R = 25.0
      CAM_MIN = 15.0
      THICKNESS = 10.0
      BORE_D = 8.0
      ECCENTRICITY = (CAM_R - CAM_MIN) / 2
      MEAN_R = (CAM_R + CAM_MIN) / 2
      with BuildPart() as part:
          with Locations((ECCENTRICITY, 0, 0)):
              Cylinder(radius=MEAN_R, height=THICKNESS)
          # Bore at true center (0,0)
          Hole(radius=BORE_D / 2, depth=THICKNESS)
      result = part.part

  # G. Hinge & Flexure

  - title: "Living hinge (thin flexure bridge)"
    description: "Two rigid blocks connected by a thin (0.4mm) flexure bridge for fold-over hinge"
    code: |
      from build123d import *
      BLOCK_W = 40.0
      BLOCK_D = 30.0
      BLOCK_H = 5.0
      HINGE_T = 0.4
      HINGE_L = 2.0
      GAP = HINGE_L
      with BuildPart() as part:
          # Left block
          Box(BLOCK_W, BLOCK_D, BLOCK_H)
          # Right block
          with Locations((BLOCK_W + GAP, 0, 0)):
              Box(BLOCK_W, BLOCK_D, BLOCK_H)
          # Thin bridge
          with Locations((BLOCK_W / 2 + GAP / 2, 0, BLOCK_H / 2 - HINGE_T / 2)):
              Box(GAP + 2, BLOCK_D, HINGE_T)
      result = part.part

  # H. Surface Features & Cutouts

  - title: "USB-C port cutout"
    description: "Panel plate with a USB-C shaped rounded-rectangle cutout (8.94 x 3.26mm)"
    code: |
      from build123d import *
      PANEL_W = 40.0
      PANEL_H = 30.0
      PANEL_T = 2.0
      USB_W = 8.94
      USB_H = 3.26
      with BuildPart() as part:
          Box(PANEL_W, PANEL_H, PANEL_T)
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):
              SlotOverall(USB_W, USB_H)
          extrude(amount=-PANEL_T, mode=Mode.SUBTRACT)
      result = part.part

  - title: "D-sub connector cutout (DE-9)"
    description: "Panel plate with trapezoidal D-sub cutout using real DE-9 dimensions"
    code: |
      from build123d import *
      PANEL_W = 50.0
      PANEL_H = 30.0
      PANEL_T = 2.0
      TOP_W = 16.0
      BOT_W = 12.5
      D_H = 10.0
      trap_pts = [
          (-BOT_W / 2, -D_H / 2),
          (BOT_W / 2, -D_H / 2),
          (TOP_W / 2, D_H / 2),
          (-TOP_W / 2, D_H / 2),
      ]
      with BuildPart() as part:
          Box(PANEL_W, PANEL_H, PANEL_T)
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):
              with BuildLine() as ln:
                  Polyline(trap_pts)
                  Line(trap_pts[-1], trap_pts[0])
              make_face()
          extrude(amount=-PANEL_T, mode=Mode.SUBTRACT)
      result = part.part

  # I. Small Items

  - title: "Cable gland / grommet (revolved stepped profile)"
    description: "Revolve a stepped profile to create a cable gland with flange, body, and bore"
    code: |
      from build123d import *
      BORE_R = 4.0
      BODY_R = 8.0
      FLANGE_R = 12.0
      pts = [
          (BORE_R, 0), (FLANGE_R, 0), (FLANGE_R, 3),
          (BODY_R, 3), (BODY_R, 7),
          (BODY_R + 1, 7), (BODY_R + 1, 9),
          (BODY_R, 9), (BODY_R, 18),
          (BORE_R, 18),
      ]
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(pts)
                  Line(pts[-1], pts[0])
              make_face()
          revolve(axis=Axis.Z)
      result = part.part

  - title: "Keychain tag (rounded plate + text + ring hole)"
    description: "Rounded rectangle plate with embossed text and a ring attachment hole"
    code: |
      from build123d import *
      TAG_W = 50.0
      TAG_H = 25.0
      TAG_T = 3.0
      CORNER_R = 5.0
      RING_HOLE_D = 5.0
      with BuildPart() as part:
          with BuildSketch() as sk:
              RectangleRounded(TAG_W, TAG_H, CORNER_R)
          extrude(amount=TAG_T)
          # Ring hole on one end
          with Locations((-TAG_W / 2 + 8, 0)):
              Hole(radius=RING_HOLE_D / 2, depth=TAG_T)
          # Text on top face
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):
              with Locations((5, 0)):
                  Text("TAG", font_size=8.0)
          extrude(amount=0.5)
      result = part.part

# =============================================================================
# ANTI-PATTERN LIBRARY - Common Build123d Mistakes
# =============================================================================
# Each entry shows wrong code, the error it produces, why it fails, and the fix.

anti_patterns:
  - title: "Fillet before boolean"
    wrong_code: |
      with BuildPart() as part:
          Box(20, 20, 10)
          fillet(part.edges().filter_by(Axis.Z), radius=2.0)
          with Locations((0, 0, 10)):
              Box(10, 10, 5)  # boolean union after fillet
    error_message: "StdFail_NotDone: BRep_Tool - filleted edges conflict with boolean operation"
    explanation: "Fillet modifies edge topology. When you add geometry after filleting, the kernel cannot reconcile the changed edges. Always apply fillets and chamfers as the LAST operation, after all booleans are complete."
    correct_code: |
      with BuildPart() as part:
          Box(20, 20, 10)
          with Locations((0, 0, 10)):
              Box(10, 10, 5)
          fillet(part.edges().filter_by(Axis.Z), radius=2.0)
      result = part.part

  - title: "offset_3d on complex boolean body"
    wrong_code: |
      with BuildPart() as part:
          Box(40, 40, 20)
          for i in range(5):
              with Locations((i*8 - 16, 0, 0)):
                  Cylinder(radius=3, height=25)
          offset_3d(openings=part.faces().sort_by(Axis.Z)[-1], amount=-2.0)
    error_message: "StdFail_NotDone: BRep_API - offset_3d operation failed on complex body"
    explanation: "offset_3d (shell equivalent) struggles with bodies that have many boolean seams. The kernel cannot offset complex intersecting surfaces reliably. Either offset_3d EARLY (on a simple shape) or use manual hollowing by subtracting a smaller inner solid."
    correct_code: |
      with BuildPart() as part:
          Box(40, 40, 20)
          # Hollow first, then add features
          with Locations((0, 0, 1)):
              Box(36, 36, 19, mode=Mode.SUBTRACT)
          for i in range(5):
              with Locations((i*8 - 16, 0, 0)):
                  Cylinder(radius=3, height=25)
      result = part.part

  - title: "Revolve profile crossing axis"
    wrong_code: |
      pts = [(-5, 0), (15, 0), (15, 30), (-5, 30)]
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(pts)
                  Line(pts[-1], pts[0])
              make_face()
          revolve(axis=Axis.Z)
    error_message: "Standard_ConstructionError: profile crosses the revolve axis"
    explanation: "The profile extends to X=-5, which crosses the revolve axis at X=0. ALL profile points must be on the same side of the axis (positive X for revolve around Z on XZ plane). Move the profile so its minimum X coordinate is >= 0."
    correct_code: |
      pts = [(0, 0), (15, 0), (15, 30), (0, 30)]
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(pts)
                  Line(pts[-1], pts[0])
              make_face()
          revolve(axis=Axis.Z)
      result = part.part

  - title: "Boolean on non-overlapping bodies"
    wrong_code: |
      with BuildPart() as part:
          Box(40, 40, 5)
          # Cutter sits exactly on top surface - does not penetrate
          with Locations((0, 0, 5)):
              Box(10, 10, 10, mode=Mode.SUBTRACT)
    error_message: "No error - but the cut has no visible effect (silent no-op)"
    explanation: "The cutting tool must OVERLAP the target body. If it only touches a face or sits outside, the boolean produces no change. Always extend the cutter BEYOND the target surface by at least 0.1mm."
    correct_code: |
      with BuildPart() as part:
          Box(40, 40, 5)
          # Cutter extends into the plate
          with Locations((0, 0, 4)):
              Box(10, 10, 10, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Fillet radius too large"
    wrong_code: |
      with BuildPart() as part:
          Box(10, 10, 5)
          fillet(part.edges().filter_by(Axis.Z), radius=8.0)
    error_message: "StdFail_NotDone: BRep_Tool - fillet radius exceeds edge length"
    explanation: "The box is 10mm wide but the fillet radius is 8mm. The fillet radius must be LESS than half the shortest adjacent edge. For a 10mm edge, max safe fillet is ~4.5mm. Always keep fillet radius well below half the smallest dimension."
    correct_code: |
      with BuildPart() as part:
          Box(10, 10, 5)
          fillet(part.edges().filter_by(Axis.Z), radius=2.0)
      result = part.part

  - title: "Blanket fillet on complex geometry"
    wrong_code: |
      # After building complex loft+boolean geometry
      fillet(part.edges(), radius=2.0)
    error_message: "StdFail_NotDone: BRep_API: command not done"
    explanation: "Calling fillet() on ALL edges of geometry built from loft, offset_3d, and multiple boolean operations tries to fillet EVERY edge including tiny internal edges. The kernel cannot compute fillets on many of these edges. Wrap in try/except for graceful degradation, or use selective edge fillet."
    correct_code: |
      try:
          fillet(part.edges(), radius=2.0)
      except Exception:
          pass  # graceful degradation
      result = part.part

  - title: "Too many chained booleans"
    wrong_code: |
      with BuildPart() as part:
          Box(80, 80, 5)
          for i in range(15):
              with Locations((i*5 - 35, 0, 5)):
                  Cylinder(radius=2, height=20, align=(Align.CENTER, Align.CENTER, Align.MIN))
          fillet(part.edges().filter_by(Axis.Z), radius=1.0)
    error_message: "OCP kernel crash or tolerance drift - geometry becomes invalid after many booleans"
    explanation: "Each boolean operation accumulates floating-point tolerance errors. After 10+ unions the geometry may become invalid, causing downstream operations (fillet) to crash. Use GridLocations or batch patterns instead of individual boolean loops."
    correct_code: |
      with BuildPart() as part:
          Box(80, 80, 5)
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):
              with Locations([(i*5 - 35, 0) for i in range(15)]):
                  Circle(2)
          extrude(amount=20)
      result = part.part

  - title: "Wrong face selection"
    wrong_code: |
      with BuildPart() as part:
          Box(40, 40, 10)
          # Intent: drill holes on TOP face
          with BuildSketch(part.faces().sort_by(Axis.X)[-1]):  # WRONG: selects front face
              with Locations([(10, 0), (-10, 0)]):
                  Circle(2.5)
          extrude(amount=-10, mode=Mode.SUBTRACT)
    error_message: "No crash - but holes appear on the wrong face (front instead of top)"
    explanation: "Face selectors use sort_by(Axis.Z)[-1] for top, sort_by(Axis.Z)[0] for bottom, sort_by(Axis.X)[-1] for front. Mixing up axes puts features on the wrong face."
    correct_code: |
      with BuildPart() as part:
          Box(40, 40, 10)
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):  # CORRECT: top face
              with Locations([(10, 0), (-10, 0)]):
                  Circle(2.5)
          extrude(amount=-10, mode=Mode.SUBTRACT)
      result = part.part

  - title: "Missing make_face() in sketch with BuildLine"
    wrong_code: |
      with BuildPart() as part:
          with BuildSketch() as sk:
              with BuildLine() as ln:
                  Polyline([(0, 0), (10, 0), (10, 10), (0, 10)])
                  Line((0, 10), (0, 0))
              # Missing make_face()!
          extrude(amount=5)
    error_message: "ValueError: No faces to extrude"
    explanation: "When using BuildLine inside BuildSketch, you must call make_face() after closing the line to convert the wire into a face that can be extruded."
    correct_code: |
      with BuildPart() as part:
          with BuildSketch() as sk:
              with BuildLine() as ln:
                  Polyline([(0, 0), (10, 0), (10, 10), (0, 10)])
                  Line((0, 10), (0, 0))
              make_face()
          extrude(amount=5)
      result = part.part

# =============================================================================
# BUILD123D API QUICK-REFERENCE
# =============================================================================
# Compact reference for error-prone operations.

api_reference:
  - operation: "loft()"
    signature: "loft(ruled=False) inside BuildPart context with multiple BuildSketch sections"
    returns: "Adds a lofted solid between pending sketches on different planes"
    params:
      - "ruled (bool): True for straight ruled surface between profiles, False for smooth"
    gotchas:
      - "Each profile must be in its own BuildSketch on a separate plane (use Plane.XY.offset(N))"
      - "Profiles with very different edge counts (e.g. Rectangle to Circle) may twist - use ruled=True"
      - "Minimum 2 profiles required; profiles must not self-intersect"

  - operation: "sweep()"
    signature: "sweep() inside BuildPart context after BuildLine (path) + BuildSketch (profile)"
    returns: "Adds a swept solid"
    params:
      - "Define path first with BuildLine, then profile with BuildSketch perpendicular to path start"
    gotchas:
      - "Path must be defined first as a BuildLine"
      - "Profile should be perpendicular to the path start tangent"
      - "Self-intersecting sweep (tight curves with large profile) produces invalid geometry"

  - operation: "revolve()"
    signature: "revolve(axis=Axis.Z, revolution_arc=360) inside BuildPart context"
    returns: "Adds a revolved solid from the pending sketch"
    params:
      - "axis: Axis of revolution (Axis.X, Axis.Y, Axis.Z)"
      - "revolution_arc (float): rotation angle in degrees, 360 for full revolution"
    gotchas:
      - "CRITICAL: Profile must be ENTIRELY on one side of the revolve axis"
      - "For XZ plane revolve around Z: all X coordinates must be >= 0"
      - "Profile must be a closed face (use make_face() after BuildLine)"

  - operation: "offset_3d()"
    signature: "offset_3d(openings=face, amount=-thickness)"
    returns: "Hollows the current solid, opening at the specified face"
    params:
      - "openings: face(s) to remove (e.g. part.faces().sort_by(Axis.Z)[-1])"
      - "amount (float): negative = shell inward (common), positive = shell outward"
    gotchas:
      - "offset_3d FAILS on bodies with complex boolean seams - use it EARLY or use boolean subtraction"
      - "Thin features or sharp internal corners cause kernel failures"
      - "Prefer boolean subtraction (outer - inner) for complex geometry"

  - operation: "Face/edge selectors"
    signature: "part.faces().sort_by(Axis.Z)[-1] / part.edges().filter_by(Axis.Z)"
    returns: "Selected faces or edges"
    params:
      - "sort_by(Axis.Z)[-1]: topmost face (highest Z)"
      - "sort_by(Axis.Z)[0]: bottommost face (lowest Z)"
      - "filter_by(Axis.Z): edges parallel to Z axis (vertical edges)"
      - "sort_by(Axis.Z)[-4:]: top 4 edges (e.g. top horizontal edges of a box)"
    gotchas:
      - "sort_by returns ordered list - [-1] is max, [0] is min"
      - "filter_by returns edges parallel to the given axis"
      - "After booleans, face counts change - be careful with indices"

  - operation: "Locations / GridLocations / PolarLocations"
    signature: "with Locations(pts) / with GridLocations(x_spacing, y_spacing, x_count, y_count) / with PolarLocations(radius, count)"
    returns: "Context manager placing subsequent objects at each location"
    params:
      - "Locations: list of (x,y) or (x,y,z) tuples"
      - "GridLocations: rectangular grid by spacing and count"
      - "PolarLocations: points on a circle - radius and count"
    gotchas:
      - "Locations are relative to the current context (BuildPart or BuildSketch)"
      - "Operations inside the Locations context execute once at EACH location"

  - operation: "BuildPart / BuildSketch / BuildLine"
    signature: "with BuildPart() as part: / with BuildSketch(plane) as sk: / with BuildLine() as ln:"
    returns: "Context managers for 3D part, 2D sketch, or 1D line construction"
    params:
      - "BuildPart: no required params; result is part.part"
      - "BuildSketch: optional plane arg (Plane.XY, face, Plane.XY.offset(N))"
      - "BuildLine: no required params; used inside BuildSketch for complex profiles"
    gotchas:
      - "BuildSketch inside BuildPart automatically adds sketch for subsequent extrude()"
      - "BuildLine inside BuildSketch requires make_face() to close and fill"
      - "Always extract result as part.part from the outermost BuildPart"

# =============================================================================
# REAL-WORLD DIMENSION TABLES
# =============================================================================
# Use these dimensions instead of guessing. All values in mm.

dimension_tables:
  - category: "Metric Fasteners (ISO 4762 / ISO 4032)"
    description: "Socket-head cap screw + hex nut dimensions. All values in mm."
    data:
      - "M2: shaft=2.0, head_dia=3.8, head_h=2.0, nut_af=4.0, nut_h=1.6, clearance_hole=2.4"
      - "M3: shaft=3.0, head_dia=5.5, head_h=3.0, nut_af=5.5, nut_h=2.4, clearance_hole=3.4"
      - "M4: shaft=4.0, head_dia=7.0, head_h=4.0, nut_af=7.0, nut_h=3.2, clearance_hole=4.5"
      - "M5: shaft=5.0, head_dia=8.5, head_h=5.0, nut_af=8.0, nut_h=4.7, clearance_hole=5.5"
      - "M6: shaft=6.0, head_dia=10.0, head_h=6.0, nut_af=10.0, nut_h=5.2, clearance_hole=6.6"
      - "M8: shaft=8.0, head_dia=13.0, head_h=8.0, nut_af=13.0, nut_h=6.8, clearance_hole=9.0"
      - "M10: shaft=10.0, head_dia=16.0, head_h=10.0, nut_af=16.0, nut_h=8.4, clearance_hole=11.0"
      - "M12: shaft=12.0, head_dia=18.0, head_h=12.0, nut_af=18.0, nut_h=10.8, clearance_hole=13.5"

  - category: "Common Electronics Dimensions"
    description: "Board and connector dimensions for enclosure design. All values in mm."
    data:
      - "Raspberry Pi 4: board=85x56, mount_holes=58x49 (M2.5), height_with_ports=17"
      - "Arduino Uno: board=69x53, mount_holes=66x48 (M3), height_with_headers=15"
      - "ESP32 DevKit: board=51x28, pin_rows_spacing=25.4, height=6"
      - "USB-A receptacle: cutout=13.1x5.7, depth=17"
      - "USB-B receptacle: cutout=12.0x11.0, depth=16"
      - "USB-C receptacle: cutout=8.94x3.26, corner_r=1.0, depth=7.5"
      - "Micro-USB receptacle: cutout=7.5x2.7, depth=6"
      - "SD card slot: cutout=12.0x2.5, depth=14; microSD: cutout=12.0x1.5, depth=13"
      - "18650 battery: dia=18.5, length=65.2 (with protection circuit), bare=18.3x65.0"

  - category: "Bearing Dimensions (ISO 15)"
    description: "Common deep-groove ball bearings. ID=inner dia, OD=outer dia, W=width. All mm."
    data:
      - "608 (skateboard): ID=8, OD=22, W=7"
      - "6001: ID=12, OD=28, W=8"
      - "6201: ID=12, OD=32, W=10"
      - "6202: ID=15, OD=35, W=11"
      - "6203: ID=17, OD=40, W=12"
      - "6204: ID=20, OD=47, W=14"
      - "Bearing seat fit: bore=OD+0.000/+0.013 (H7), shaft=ID-0.000/-0.011 (h6)"

  - category: "Common Object Sizes"
    description: "Everyday objects for reference when modeling enclosures or holders. All mm."
    data:
      - "Smartphone (typical): 150x73x8"
      - "Credit card (ISO 7810): 85.6x53.98x0.76"
      - "AA battery: dia=14.5, length=50.5"
      - "AAA battery: dia=10.5, length=44.5"
      - "US quarter: dia=24.26, thickness=1.75; Euro 1: dia=23.25, thickness=2.33"
      - "Standard pen/pencil: dia=7-8, length=140-190"
      - "Coffee mug (typical): dia=80-85, height=95, handle_clearance=30"
      - "Tennis ball: dia=67"

  - category: "Clearance and Press-Fit Tolerances (ISO 286)"
    description: "Standard tolerance pairs for shaft-in-hole fits. Gap values for nominal 10-50mm range."
    data:
      - "H7/g6 (sliding fit): gap=+0.010 to +0.050 - shaft turns freely, good for bearings"
      - "H7/h6 (location fit): gap=0.000 to +0.039 - snug, locates accurately, removable by hand"
      - "H7/k6 (transition fit): gap=-0.018 to +0.021 - may need light press, slight interference possible"
      - "H7/p6 (press fit): gap=-0.042 to -0.001 - requires press or heat, permanent assembly"
      - "Rule of thumb: clearance=+0.1mm per 25mm nominal for easy sliding; press=-0.02 to -0.05mm"
      - "For 3D prints: add +0.2mm to clearance fits to compensate for layer squish and shrinkage"

  - category: "3D Printing Clearance Guidelines (FDM)"
    description: "Practical clearances for FDM printers at 0.2mm layer height. Adjust for resin/SLS."
    data:
      - "Mating flat surfaces (sliding): 0.3-0.5mm gap per side"
      - "Pin in hole (loose fit): hole_dia = pin_dia + 0.4mm"
      - "Pin in hole (snug fit): hole_dia = pin_dia + 0.2mm"
      - "Threaded insert M3: hole_dia=4.0; M4: hole_dia=5.0; M5: hole_dia=6.4"
      - "Snap-fit cantilever: arm_thickness=1.0-1.5mm, deflection<arm_length*0.02"
      - "Living hinge (single-use fold): thickness=0.3-0.5mm, width>=10mm"
      - "Minimum wall thickness: 0.8mm (2 perimeters at 0.4mm nozzle)"
      - "Minimum hole diameter (reliable): 2.0mm"

  - category: "Sheet Metal Bend Radii"
    description: "Minimum inside bend radii by material and thickness. All values in mm."
    data:
      - "Aluminum 5052-H32: t<=1.6 -> R=0, t=2.0 -> R=1.0, t=3.0 -> R=1.5"
      - "Aluminum 6061-T6: t<=1.6 -> R=1.0t, t=2.0 -> R=1.5t, t=3.0 -> R=2.0t"
      - "Mild steel (A36): t<=1.6 -> R=0.5t, t=2.0 -> R=1.0t, t=3.0 -> R=1.5t"
      - "Stainless 304: t<=1.6 -> R=1.0t, t=2.0 -> R=1.5t, t=3.0 -> R=2.0t"
      - "K-factor (neutral axis): 0.33 for air bend, 0.44 for bottoming, 0.50 for coining"
      - "Minimum flange length: 4t + R (material thickness x 4 + bend radius)"
      - "Hole-to-bend distance: >=2.5t + R to avoid distortion"

# =============================================================================
# DIMENSION ESTIMATION GUIDANCE
# =============================================================================
dimension_guidance:
  when_to_estimate:
    - "For real-world objects (mug, bolt, phone case, bracket), use typical dimensions from the dimension tables or common knowledge"
    - "For abstract or custom parts ('make a bracket for my project'), ask the user for critical dimensions"
    - "If the user specifies ANY dimension, respect it exactly and derive others proportionally"
    - "If the user says 'small', 'medium', or 'large', use the size class mapping below"
    - "When in doubt, pick reasonable defaults and state your assumptions in the response"

  size_classes:
    - "Tiny: < 20mm (jewelry, pins, screws, electronic components)"
    - "Small: 20-60mm (knobs, buttons, small brackets, connectors)"
    - "Medium: 60-150mm (handles, phone cases, small enclosures, cups)"
    - "Large: 150-500mm (helmets, laptop stands, large enclosures, boxes)"
    - "Extra-large: > 500mm (furniture, structural parts, shelving)"

  scale_anchors:
    - "Human hand: ~190mm long, ~85mm wide"
    - "Human finger: ~20mm diameter, ~80mm long"
    - "Desktop objects: typically 50-300mm"
    - "Pocket-sized objects: 40-120mm longest dimension"
    - "AA battery: 50.5mm long, 14.5mm diameter"
    - "Credit card: 85.6 x 54.0mm"

  proportional_reasoning:
    - "A handle/grip: ~120mm long, ~30mm diameter"
    - "A knob: ~25-40mm diameter, ~15-25mm tall"
    - "A wall hook: ~50mm projection, ~80mm tall"
    - "A mug/cup: ~80mm diameter, ~95mm tall, ~2mm wall"
    - "A coaster: ~90mm diameter, ~5mm thick"
    - "A phone stand: ~80mm wide, ~120mm tall, ~100mm deep"
    - "A pen holder: ~40mm diameter, ~100mm tall"
    - "A soap dish: ~120mm long, ~80mm wide, ~15mm deep"

  relative_sizing:
    - "Lid or cap: 0.5-1.0mm clearance over container in X and Y"
    - "Container wall thickness: 2-3mm (3D printing), 1-2mm (CNC milling)"
    - "Screw hole clearance: hole diameter = screw diameter + 0.3mm"
    - "Press-fit: hole diameter = shaft diameter - 0.1mm"
    - "Nesting parts: inner dimension = outer dimension - 2 x wall_thickness"
    - "Fillet radius: typically 10-20% of the smallest adjacent feature dimension"

# =============================================================================
# FAILURE PREVENTION - Proactive "If X Then Y" Rules
# =============================================================================
failure_prevention:
  self_diagnosis:
    - "If fillet() fails, first check if you are filleting ALL edges on complex geometry (loft/offset_3d/booleans) - if so, wrap in try/except or use selective edge fillet. If geometry is simple, reduce radius to 1/5 of shortest adjacent edge"
    - "If offset_3d() raises 'Standard_ConstructionError', geometry has thin walls, sharp internal corners, or non-manifold edges - use boolean subtraction hollowing instead"
    - "If loft() fails with 'profiles are incompatible', sections have different edge counts - use same number of points/edges in each profile"
    - "If revolve() produces unexpected geometry, the profile likely crosses the rotation axis - ensure all profile points are on one side"
    - "If a boolean cut (Mode.SUBTRACT) produces no visible change, the cutting tool does not intersect the target body - check position and size"
    - "If sweep() fails, the path is probably not valid - ensure BuildLine creates a connected wire"
    - "If chamfer() fails after multiple booleans, OpenCascade cannot resolve edge topology - apply chamfer earlier or use fillet instead"
    - "If error says 'no pending faces' or similar: you likely forgot make_face() after BuildLine, or the sketch has no geometry to extrude"

  preemptive_warnings:
    - "If you are about to use offset_3d() after more than 3 boolean operations, STOP - use boolean subtraction hollowing instead"
    - "If you are about to fillet edges at a boolean intersection, STOP - do booleans first, THEN fillet the result"
    - "If you are about to loft() between more than 3 profiles, consider whether stacked extrudes with fillets would be more robust"
    - "If your design requires more than 6 boolean operations, use Locations/GridLocations/PolarLocations to batch them"
    - "If a wall thickness in your design is below 1.5mm, offset_3d and boolean operations become very fragile - increase thickness or use boolean subtraction"
    - "If you are about to fillet ALL edges on a body built with loft, offset_3d, or more than 2 booleans, STOP - wrap in try/except"

  alternative_operations:
    - "If loft() fails between two profiles: extrude the base profile, then use fillet/chamfer to approximate the shape transition"
    - "If offset_3d() fails on a complex body: build the shape as hollow from the start using boolean subtraction of an inner body"
    - "If a complex sweep() fails: break the path into straight segments and use extrude + Location for each segment"
    - "If fillet() fails on specific edges: try chamfer() instead (more tolerant of edge topology issues)"
    - "If a circular pattern fails: use PolarLocations instead of manual rotation loops"
    - "If a complex 2D profile causes extrude to fail: simplify the profile to straight lines and arcs only (no splines)"

  complexity_assessment:
    - "If your code exceeds 50 lines, consider whether it can be split into named helper variables for each major feature"
    - "If you are planning more than 8 distinct operations, list them in a comment block first to verify the sequence"
    - "If the object has more than 4 distinct feature types (holes, slots, fillets, bosses, ribs), plan build order: base shape -> large features -> small details -> fillets last"

  pre_output_checklist:
    - "Before outputting code, verify: Does every fillet radius stay below half the smallest adjacent edge?"
    - "Before outputting code, verify: Are all boolean cutting tools positioned to actually intersect the target body?"
    - "Before outputting code, verify: Is offset_3d() applied BEFORE small features (or not at all - prefer boolean subtraction)?"
    - "Before outputting code, verify: Does the code assign the final solid to 'result = part.part'?"
    - "Before outputting code, verify: Are all dimensions realistic (no zero-thickness walls, no negative sizes, no features larger than the body)?"
    - "Before outputting code, verify: If using loft(), do all profiles have the same number of edges/points?"
    - "Before outputting code, verify: If using revolve(), is the profile entirely on one side of the rotation axis?"
    - "Before outputting code, verify: Are fillets and chamfers applied as the LAST operations (after all booleans)?"
    - "Before outputting code, verify: If filleting ALL edges after loft/offset_3d/multiple booleans, is it wrapped in try/except?"
    - "Before outputting code, verify: Does every BuildLine inside BuildSketch end with make_face()?"

# =============================================================================
# FEW-SHOT EXAMPLES: Design-to-Code Workflow
# =============================================================================
few_shot_examples:
  - user_request: "Make me a coffee mug"
    design_plan: |
      Revolve a polyline half-profile to form the mug body (cylinder with thick base).
      Hollow the body using boolean subtraction.
      Sweep a circle along a C-shaped arc to form the handle.
      Add handle to body, then fillet joint edges last.
    code: |
      from build123d import *
      MUG_OD = 82.0
      MUG_H = 95.0
      WALL = 3.0
      HANDLE_R = 3.5
      body_pts = [
          (0, 0), (MUG_OD / 2, 0), (MUG_OD / 2, MUG_H), (0, MUG_H),
      ]
      with BuildPart() as part:
          # Mug body via revolve
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(body_pts)
                  Line(body_pts[-1], body_pts[0])
              make_face()
          revolve(axis=Axis.Z)
          # Hollow interior (boolean subtraction)
          inner_pts = [
              (0, WALL), (MUG_OD / 2 - WALL, WALL),
              (MUG_OD / 2 - WALL, MUG_H + 1), (0, MUG_H + 1),
          ]
          with BuildSketch(Plane.XZ) as sk2:
              with BuildLine() as ln2:
                  Polyline(inner_pts)
                  Line(inner_pts[-1], inner_pts[0])
              make_face()
          revolve(axis=Axis.Z, mode=Mode.SUBTRACT)
          # Handle: sweep circle along arc path
          with BuildLine(Plane.XZ) as handle_path:
              ThreePointArc(
                  (MUG_OD / 2, MUG_H * 0.75),
                  (MUG_OD / 2 + 22, MUG_H * 0.5),
                  (MUG_OD / 2, MUG_H * 0.25),
              )
          with BuildSketch(Plane(origin=handle_path.line @ 0, z_dir=handle_path.line % 0)):
              Circle(HANDLE_R)
          sweep()
      try:
          fillet(part.edges(), radius=1.0)
      except Exception:
          pass
      result = part.part

  - user_request: "Design a motor mount bracket"
    design_plan: |
      Extrude an L-shaped polyline profile for the bracket body.
      Add a polar array of bolt holes on the vertical face for the motor.
      Add two mounting holes on the horizontal base.
      Apply fillets to vertical edges last for strength.
    code: |
      from build123d import *
      T = 4.0
      BASE_W = 60.0
      BASE_D = 50.0
      WALL_H = 55.0
      MOTOR_BOLT_R = 18.0
      MOTOR_BORE = 24.0
      N_BOLTS = 4
      BOLT_D = 4.5
      MOUNT_D = 5.5
      l_pts = [
          (0, 0), (BASE_W, 0), (BASE_W, T),
          (T, T), (T, WALL_H), (0, WALL_H),
      ]
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(l_pts)
                  Line(l_pts[-1], l_pts[0])
              make_face()
          extrude(amount=BASE_D)
          # Motor bolt holes on vertical face
          with BuildSketch(part.faces().sort_by(Axis.X)[0]):
              with PolarLocations(MOTOR_BOLT_R, N_BOLTS):
                  Circle(BOLT_D / 2)
          extrude(amount=-T, mode=Mode.SUBTRACT)
          # Motor center bore
          with BuildSketch(part.faces().sort_by(Axis.X)[0]):
              Circle(MOTOR_BORE / 2)
          extrude(amount=-T, mode=Mode.SUBTRACT)
          # Mounting holes on base
          with BuildSketch(part.faces().sort_by(Axis.Z)[0]):
              with Locations([(15, BASE_D / 2 - 10), (BASE_W - 15, BASE_D / 2 - 10)]):
                  Circle(MOUNT_D / 2)
          extrude(amount=-T, mode=Mode.SUBTRACT)
          fillet(part.edges().filter_by(Axis.Z), radius=2.0)
      result = part.part

  - user_request: "Create an SD card holder"
    design_plan: |
      Start with a box slightly larger than an SD card (26 x 34 x 6mm).
      Fillet vertical edges for rounded corners, then hollow via boolean subtraction.
      Cut a slot on the front face for card insertion.
      Cut a thumb notch on the back wall so the card can be pushed out.
    code: |
      from build123d import *
      W = 28.0
      D = 36.0
      H = 6.0
      WALL = 1.5
      SLOT_W = 24.5
      SLOT_H = 2.5
      NOTCH_W = 12.0
      NOTCH_H = 4.0
      with BuildPart() as part:
          Box(W, D, H)
          fillet(part.edges().filter_by(Axis.Z), radius=3.0)
          # Hollow interior
          with Locations((0, 0, WALL / 2)):
              Box(W - 2*WALL, D - 2*WALL, H - WALL, mode=Mode.SUBTRACT)
          # Card insertion slot on front face
          with Locations((0, D / 2, 0)):
              Box(SLOT_W, WALL * 3, SLOT_H, mode=Mode.SUBTRACT)
          # Thumb notch on back wall
          with Locations((0, -D / 2, H / 4)):
              Box(NOTCH_W, WALL * 3, NOTCH_H, mode=Mode.SUBTRACT)
      result = part.part

  - user_request: "Make a gear"
    design_plan: |
      Calculate tooth geometry from module and tooth count using math.
      Build a root circle disc, then create one trapezoidal tooth profile.
      Rotate and union the tooth N times around the center.
      Drill a center bore for the shaft.
    code: |
      from build123d import *
      import math
      N_TEETH = 16
      MODULE = 2.0
      FACE_W = 10.0
      BORE_D = 8.0
      PD = MODULE * N_TEETH
      OD = PD + 2 * MODULE
      RD = PD - 2.5 * MODULE
      TOOTH_ARC = 360.0 / N_TEETH
      HALF_T = TOOTH_ARC / 4
      r_root = RD / 2
      r_tip = OD / 2
      a = math.radians(HALF_T)
      tooth_pts = [
          (r_root * math.cos(-a * 1.2), r_root * math.sin(-a * 1.2)),
          (r_tip * math.cos(-a * 0.4), r_tip * math.sin(-a * 0.4)),
          (r_tip * math.cos(a * 0.4), r_tip * math.sin(a * 0.4)),
          (r_root * math.cos(a * 1.2), r_root * math.sin(a * 1.2)),
      ]
      with BuildPart() as part:
          Cylinder(radius=r_root, height=FACE_W)
          for i in range(N_TEETH):
              angle = i * TOOTH_ARC
              cos_a = math.cos(math.radians(angle))
              sin_a = math.sin(math.radians(angle))
              rotated = [(x * cos_a - y * sin_a, x * sin_a + y * cos_a)
                         for x, y in tooth_pts]
              with BuildSketch() as tsk:
                  with BuildLine() as tln:
                      Polyline(rotated)
                      Line(rotated[-1], rotated[0])
                  make_face()
              extrude(amount=FACE_W)
          Hole(radius=BORE_D / 2, depth=FACE_W)
      result = part.part

  - user_request: "Design a phone stand"
    design_plan: |
      Create a flat rectangular base for stability.
      Loft between two angled rectangular profiles to form the upright support.
      Add a small lip/ledge at the bottom of the support to cradle the phone.
      Combine all parts, then fillet edges last.
    code: |
      from build123d import *
      BASE_W = 80.0
      BASE_D = 60.0
      BASE_H = 5.0
      SUPPORT_T = 6.0
      SUPPORT_H = 70.0
      LIP_D = 15.0
      LIP_H = 3.0
      with BuildPart() as part:
          # Base plate
          Box(BASE_W, BASE_D, BASE_H)
          # Angled support via loft
          with BuildSketch(Plane.XY.offset(BASE_H)) as sk1:
              with Locations((0, -BASE_D / 2 + SUPPORT_T / 2)):
                  Rectangle(BASE_W * 0.8, SUPPORT_T)
          with BuildSketch(Plane.XY.offset(BASE_H + SUPPORT_H)) as sk2:
              with Locations((0, -BASE_D / 2 + SUPPORT_T / 2 + SUPPORT_H * 0.26)):
                  Rectangle(BASE_W * 0.7, SUPPORT_T)
          loft()
          # Lip to hold the phone
          with Locations((0, -BASE_D / 2 + LIP_D / 2, BASE_H)):
              Box(BASE_W * 0.6, LIP_D, LIP_H, align=(Align.CENTER, Align.CENTER, Align.MIN))
      try:
          fillet(part.edges(), radius=1.5)
      except Exception:
          pass
      result = part.part

# =============================================================================
# DESIGN PATTERNS - Parameterized Templates
# =============================================================================
design_patterns:
  - name: "Enclosure"
    description: "Box-shaped housing with base + lid, screw bosses, lip/groove alignment"
    keywords: ["enclosure", "housing", "case", "box with lid", "container", "electronics case"]
    parameters:
      - "INNER_W (mm): Interior width"
      - "INNER_D (mm): Interior depth"
      - "INNER_H (mm): Interior height (base portion)"
      - "WALL (mm): Wall thickness, typically 2-3mm"
      - "LIP_H (mm): Alignment lip on base, typically 2-3mm"
      - "BOSS_OD (mm): Screw boss outer diameter"
      - "BOSS_ID (mm): Screw hole diameter (M3=3.2, M2.5=2.7)"
    base_code: |
      from build123d import *
      INNER_W, INNER_D, INNER_H = 60.0, 40.0, 25.0
      WALL, LIP_H = 2.5, 2.0
      BOSS_OD, BOSS_ID = 7.0, 3.2
      OW, OD_val, OH = INNER_W + 2*WALL, INNER_D + 2*WALL, INNER_H + WALL
      with BuildPart() as part:
          # Outer box, hollowed
          Box(OW, OD_val, OH)
          with Locations((0, 0, WALL / 2)):
              Box(INNER_W, INNER_D, INNER_H, mode=Mode.SUBTRACT)
          # Corner screw bosses
          bx, by = INNER_W/2 - BOSS_OD/2, INNER_D/2 - BOSS_OD/2
          for cx, cy in [(bx,by),(-bx,by),(-bx,-by),(bx,-by)]:
              with Locations((cx, cy, -OH/2 + WALL)):
                  Cylinder(radius=BOSS_OD/2, height=INNER_H, align=(Align.CENTER, Align.CENTER, Align.MIN))
          for cx, cy in [(bx,by),(-bx,by),(-bx,-by),(bx,-by)]:
              with Locations((cx, cy, 0)):
                  Hole(radius=BOSS_ID/2, depth=OH)
          # Alignment lip
          with Locations((0, 0, OH/2)):
              with BuildSketch() as lip_sk:
                  Rectangle(INNER_W - 0.4, INNER_D - 0.4)
              extrude(amount=LIP_H)
      result = part.part
    variants:
      - "Snap-fit: replace screw bosses with snap-fit hooks on walls"
      - "Gasket groove: add 1mm wide, 0.8mm deep groove around lip"
      - "Ventilation: add slot array on side walls"
    gotchas:
      - "Hollow the base BEFORE adding screw bosses"
      - "Lip height must be less than base interior height"
      - "Leave 0.3-0.5mm clearance between lip and lid groove for fit"

  - name: "Rotational Body"
    description: "Revolve a 2D profile: bottles, cups, vases, turned parts"
    keywords: ["revolve", "vase", "bottle", "cup", "bowl", "turned", "lathe", "rotational"]
    parameters:
      - "PROFILE_PTS: list of (radius, z) tuples defining half-profile"
      - "WALL_T (mm): Wall thickness if hollow (0 for solid)"
      - "ANGLE (deg): Revolve angle, 360 for full rotation"
    base_code: |
      from build123d import *
      PROFILE = [(0, 0), (30, 0), (25, 20), (15, 60), (18, 90), (20, 100), (0, 100)]
      WALL_T = 2.5
      with BuildPart() as part:
          with BuildSketch(Plane.XZ) as sk:
              with BuildLine() as ln:
                  Polyline(PROFILE)
                  Line(PROFILE[-1], PROFILE[0])
              make_face()
          revolve(axis=Axis.Z)
          if WALL_T > 0:
              offset_3d(openings=part.faces().sort_by(Axis.Z)[-1], amount=-WALL_T)
      result = part.part
    variants:
      - "Solid body: set WALL_T = 0, skip hollowing"
      - "Flanged base: widen bottom profile points for a stable foot"
    gotchas:
      - "Profile must stay entirely on one side of the rotation axis (all r >= 0)"
      - "Close the profile by returning to (0, z_top) then the line closes back"
      - "offset_3d after revolve can fail on thin sections - check min wall vs shell thickness"

  - name: "Plate / Bracket"
    description: "Flat plate with holes, stiffening ribs, mounting features"
    keywords: ["plate", "bracket", "mount", "L-bracket", "mounting plate", "panel", "baseplate"]
    parameters:
      - "WIDTH (mm): Plate width"
      - "HEIGHT (mm): Plate height"
      - "THICK (mm): Plate thickness"
      - "HOLE_DIA (mm): Mounting hole diameter"
      - "HOLE_SPACING (mm): Distance between holes"
      - "RIB_T (mm): Rib thickness (0 for no ribs)"
    base_code: |
      from build123d import *
      WIDTH, HEIGHT, THICK = 80.0, 60.0, 4.0
      HOLE_DIA, HOLE_MARGIN = 5.0, 10.0
      RIB_T, RIB_H = 2.0, 8.0
      with BuildPart() as part:
          Box(WIDTH, HEIGHT, THICK)
          hx, hy = WIDTH/2 - HOLE_MARGIN, HEIGHT/2 - HOLE_MARGIN
          with BuildSketch(part.faces().sort_by(Axis.Z)[-1]):
              with Locations([(hx,hy),(-hx,hy),(-hx,-hy),(hx,-hy)]):
                  Circle(HOLE_DIA / 2)
          extrude(amount=-THICK, mode=Mode.SUBTRACT)
          if RIB_T > 0:
              with Locations((0, 0, -THICK/2 - RIB_H/2)):
                  Box(WIDTH * 0.8, RIB_T, RIB_H)
      result = part.part
    variants:
      - "L-bracket: add a perpendicular flange"
      - "T-bracket: add flanges on both sides"
      - "Slotted holes: use SlotOverall instead of Circle for adjustment"
    gotchas:
      - "Place holes AFTER creating the plate"
      - "Rib height should not exceed 3x plate thickness for printability"
      - "Use Locations for hole patterns"

  - name: "Tube / Pipe"
    description: "Hollow cylinder with optional bends, flanges, fittings"
    keywords: ["tube", "pipe", "elbow", "conduit", "cylinder hollow", "piping"]
    parameters:
      - "OUTER_DIA (mm): Outer diameter"
      - "INNER_DIA (mm): Inner diameter (wall = (outer-inner)/2)"
      - "LENGTH (mm): Straight length"
    base_code: |
      from build123d import *
      OUTER_DIA, INNER_DIA, LENGTH = 25.0, 20.0, 60.0
      with BuildPart() as part:
          Cylinder(radius=OUTER_DIA / 2, height=LENGTH)
          Cylinder(radius=INNER_DIA / 2, height=LENGTH + 1, mode=Mode.SUBTRACT)
      result = part.part
    variants:
      - "Flanged ends: add larger-diameter discs at each end"
      - "T-junction: add perpendicular pipe with boolean cuts for flow path"
      - "Reducer: loft between two different-diameter annular profiles"
    gotchas:
      - "Inner cylinder must be slightly longer to ensure clean through-cut"
      - "For T-junction, use boolean cylinder subtraction (more reliable)"

  - name: "Gear"
    description: "Toothed wheel: spur gear with involute-approximation teeth"
    keywords: ["gear", "spur gear", "cog", "toothed wheel", "gear pair", "pinion"]
    parameters:
      - "MODULE (mm): Gear module (tooth size parameter)"
      - "TOOTH_COUNT: Number of teeth"
      - "FACE_WIDTH (mm): Gear thickness"
      - "PRESSURE_ANGLE (deg): Typically 20"
      - "BORE_DIA (mm): Center bore diameter"
    base_code: |
      from build123d import *
      import math
      MODULE = 2.0
      TEETH = 20
      FACE_W = 10.0
      PA = math.radians(20)
      BORE = 8.0
      R_PITCH = MODULE * TEETH / 2
      R_OUTER = R_PITCH + MODULE
      R_ROOT = R_PITCH - 1.25 * MODULE
      tooth_half_angle = math.pi / TEETH
      pts = []
      for i in range(8):
          a = -tooth_half_angle + i * (2 * tooth_half_angle / 7)
          r = R_ROOT + (R_OUTER - R_ROOT) * (1 - abs(2 * i / 7 - 1))
          pts.append((r * math.cos(a), r * math.sin(a)))
      with BuildPart() as part:
          Cylinder(radius=R_ROOT, height=FACE_W)
          for t in range(TEETH):
              angle = t * 360 / TEETH
              cos_a = math.cos(math.radians(angle))
              sin_a = math.sin(math.radians(angle))
              rotated = [(x*cos_a - y*sin_a, x*sin_a + y*cos_a) for x, y in pts]
              with BuildSketch() as tsk:
                  with BuildLine() as tln:
                      Polyline(rotated)
                      Line(rotated[-1], rotated[0])
                  make_face()
              extrude(amount=FACE_W)
          Hole(radius=BORE / 2, depth=FACE_W)
      result = part.part
    variants:
      - "Hub with keyway: add a raised hub cylinder and keyway slot"
      - "Gear pair: generate two meshing gears at correct center distance"
    gotchas:
      - "This is a simplified involute - adequate for 3D printing, not for precision machining"
      - "Bore hole should be cut LAST after all tooth unions complete"

# =============================================================================
# OPERATION INTERACTIONS - CROSS-OPERATION REASONING RULES
# =============================================================================
operation_interactions:
  fillet_after_boolean:
    - "New edges created by boolean operations are often very short - use a smaller fillet radius (<=1mm) on boolean-created edges"
    - "Fillet as the very last step, not after each individual boolean operation"
    - "CRITICAL: On complex geometry (loft+offset_3d+boolean combinations), fillet(part.edges(), ...) frequently fails. ALWAYS wrap blanket fillet calls in try/except"
    - "If fillet fails on boolean edges, try chamfer as an alternative"
    - "For complex geometry, prefer selective edge fillet over blanket fillet"

  shell_after_fillet:
    - "Do NOT use offset_3d() after fillets - it fails on complex geometry"
    - "Instead: create outer solid, create smaller inner solid offset by wall thickness, use Mode.SUBTRACT"
    - "This boolean-subtraction approach works reliably on filleted, lofted, and swept bodies"

  loft_then_shell:
    - "Do NOT use offset_3d() on lofted bodies - lofted geometry has variable curvature that breaks the algorithm"
    - "Instead: loft both an outer and an inner profile set, then boolean-subtract the inner from the outer"

  boolean_chain_limit:
    - "After 5+ consecutive boolean operations, geometric tolerances accumulate - use Locations/GridLocations/PolarLocations to batch features"
    - "Build complex geometry in groups: create features via sketch patterns, then extrude once"

  extrude_on_face:
    - "Face selectors become ambiguous after boolean operations create new faces"
    - "After a boolean cut, sort_by(Axis.Z)[-1] may select a different face than expected"
    - "Build features in a logical order: base shape first, then features from top down"

  sweep_with_boolean:
    - "Swept bodies have complex underlying topology - avoid applying fillet() directly to sweep results"
    - "Boolean cuts on swept geometry can fail - keep cuts simple (through-holes or straight cuts)"

  revolve_then_cut:
    - "Revolved bodies create multiple symmetric faces - sort_by selectors may pick the wrong symmetric face"
    - "Cuts perpendicular to the revolution axis are more reliable than cuts tangential to the curved surface"

  operation_ordering:
    - "General safe operation order: base shape -> additive features (bosses) -> subtractive features (holes, pockets) -> fillets/chamfers"
    - "Never fillet before boolean operations - always apply fillets as the LAST modeling step"
    - "Never use offset_3d() after fillets - always hollow via boolean subtraction (outer - inner)"
    - "If sweep or loft is needed, perform it early in the build sequence before any boolean operations"

  cut_body_integrity:
    - "After EVERY Mode.SUBTRACT operation, the result should remain a single solid. If a cut goes through a wall and splits the body, reduce cut depth or widen the body"
    - "Grooves, ledges, and o-ring channels are common culprits - ensure cut depth < wall thickness"
