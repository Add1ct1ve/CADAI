# CAD AI Studio - 3D Printing Focused Agent Rules
# Optimized for FDM/SLA 3D printing with strict manufacturing constraints

version: 1

# =============================================================================
# COORDINATE SYSTEM
# =============================================================================
coordinate_system:
  description: "Right-hand coordinate system"
  x:
    direction: "length / front-back"
    positive: "forward"
  y:
    direction: "width / left-right"
    positive: "right"
  z:
    direction: "height / up-down (build direction)"
    positive: "up"
  origin: "center of bottom face (print bed contact surface)"

# =============================================================================
# SPATIAL REASONING RULES
# =============================================================================
spatial_rules:
  before_any_operation:
    - "Mentally visualize the current state of the model"
    - "Identify which faces/edges the operation targets"
    - "Verify operation will intersect existing geometry"
    - "Consider print orientation - Z is the build direction"

  boolean_cut:
    - "The cutting tool MUST overlap the target body"
    - "Position cutting tool so it extends BEYOND the target surface"
    - "Use .cut() or .cutBlind() with sufficient depth"

  boolean_fuse:
    - "Bodies MUST touch or overlap to fuse"
    - "Verify no air gap between bodies"

  extrude:
    - "Positive height = extrude in +Z direction (away from bed)"
    - "Negative height = extrude in -Z direction (into bed)"
    - "Always specify direction explicitly if not along Z"

  sketch_placement:
    - "XY plane = print bed surface (Z=0)"
    - "XZ plane = front wall (Y=0)"
    - "YZ plane = side wall (X=0)"
    - "Use .faces('>Z') to select top face for next operation"
    - "Use .faces('<Z') to select bottom face"

  natural_language_to_axis:
    - "upper / lower / top / bottom / above / below → Z axis (build direction)"
    - "left / right → Y axis"
    - "front / back / forward / backward → X axis"
    - "taller / shorter → Z dimension"
    - "wider / narrower → Y dimension"
    - "longer / shorter (depth) → X dimension"

  splitting_and_halving:
    - "CRITICAL: 'cut in half' means bisect the object along the CENTER of the relevant axis"
    - "'top half' / 'upper half' / 'bottom half' / 'lower half' → split on XY plane at Z midpoint"
    - "'left half' / 'right half' → split on XZ plane at Y midpoint"
    - "'front half' / 'back half' → split on YZ plane at X midpoint"
    - "PREFERRED METHOD — use boolean intersection with a box:"
    - "  Lower half: sphere.intersect(cq.Workplane('XY').box(R*3, R*3, R).translate((0,0,-R/2)))"
    - "  Upper half: sphere.intersect(cq.Workplane('XY').box(R*3, R*3, R).translate((0,0,R/2)))"
    - "ALTERNATIVE — use .split() (less reliable): .workplane(offset=0).split(keepBottom=True)"
    - "COMMON MISTAKE: Do NOT split along X or Y when the user says 'top/bottom' — that produces a vertical D-shape, not a horizontal hemisphere"
    - "For a sphere centered at origin, 'lower half' = everything with Z < 0, 'upper half' = everything with Z > 0"
    - "For 3D printing: a bowl/hemisphere (lower half) prints well flat-side-down on the bed"

  face_selectors:
    - "'>Z' = topmost face (highest Z value, furthest from bed)"
    - "'<Z' = bottommost face (lowest Z value, bed contact)"
    - "'>Y' = rightmost face"
    - "'<Y' = leftmost face"
    - "'>X' = front face (furthest forward)"
    - "'<X' = back face (furthest backward)"

# =============================================================================
# CADQUERY CODE REQUIREMENTS
# =============================================================================
code_requirements:
  mandatory:
    - "Always import cadquery as cq"
    - "Final result MUST be assigned to variable named 'result'"
    - "Use CadQuery's fluent API (method chaining)"
    - "All dimensions in millimeters"

  forbidden:
    - "Do NOT use show_object() or display()"
    - "Do NOT use cq.exporters directly - the runner handles export"
    - "Do NOT use matplotlib or any GUI libraries"
    - "Do NOT read/write files"

# =============================================================================
# 3D PRINTING MANUFACTURING CONSTRAINTS
# =============================================================================
manufacturing:
  process: "3D Printing (FDM/SLA)"

  wall_thickness:
    minimum: 1.2         # mm - 3 perimeters at 0.4mm nozzle
    recommended: 1.6     # mm - 4 perimeters for strength
    rule: "All walls must be >= 1.2mm thick"
    on_violation: "Warn user and suggest increasing to at least 1.2mm"

  overhangs:
    max_angle: 45         # degrees from vertical without support
    rule: "Angles > 45 degrees from vertical require support material"
    mitigation:
      - "Add chamfers instead of sharp overhangs"
      - "Use 45-degree angles where possible"
      - "Split model if large overhangs are unavoidable"
    on_violation: "Suggest redesign to reduce overhang angle or add support-friendly geometry"

  bridging:
    max_unsupported_span: 10  # mm - typical FDM bridging limit
    rule: "Unsupported horizontal spans should not exceed 10mm"
    on_violation: "Add intermediate supports or break span into shorter segments"

  holes:
    min_diameter: 2.0     # mm - smaller holes may close up
    vertical_preferred: true
    rule: "Holes < 2mm diameter may not print cleanly"
    compensation: "Add 0.2mm to hole diameter to compensate for shrinkage"

  layer_adhesion:
    avoid_thin_vertical_features: true
    min_cross_section: 2.0  # mm^2 - minimum cross-section in XY plane
    rule: "Thin vertical features may break due to poor layer adhesion"

  bed_adhesion:
    flat_bottom_required: true
    min_contact_area: 25.0  # mm^2
    rule: "Ensure adequate flat contact area with print bed"
    on_violation: "Add a brim-compatible base or redesign bottom surface"

  tolerances:
    xy_tolerance: 0.2     # mm - typical FDM XY accuracy
    z_tolerance: 0.1      # mm - layer height dependent
    press_fit_interference: 0.1  # mm
    clearance_fit_gap: 0.3      # mm
    rule: "Design with >=0.3mm clearance for moving parts"

  supports:
    auto_detect: true
    warn_threshold: 45    # degrees
    suggest_redesign_first: true
    rule: "Always prefer redesigning to eliminate supports over adding them"

# =============================================================================
# VALIDATION CHECKS
# =============================================================================
validation:
  pre_generation:
    - check: "dimensions_realistic"
      rule: "All dimensions between 0.1mm and 500mm (typical print volume)"
      on_fail: "Warn about print bed size limitations"

    - check: "wall_thickness"
      rule: "All walls >= 1.2mm thick"
      on_fail: "Flag thin walls and suggest minimum 1.2mm"

    - check: "overhang_angles"
      rule: "No unsupported overhangs > 45 degrees"
      on_fail: "Suggest chamfers or orientation change"

    - check: "cut_intersects"
      rule: "All cut operations must intersect target body"
      on_fail: "Recalculate cut position"

    - check: "flat_bottom"
      rule: "Model should have a flat surface for bed contact"
      on_fail: "Suggest adding a flat base"

  post_generation:
    - check: "mesh_watertight"
      rule: "Generated mesh must be manifold (watertight)"
      on_fail: "Report error, suggest fixes"

    - check: "no_self_intersection"
      rule: "No self-intersecting geometry"
      on_fail: "Simplify operations, rebuild step by step"

# =============================================================================
# ERROR HANDLING
# =============================================================================
on_error:
  spatial_confusion:
    - "STOP - do not guess"
    - "Draw ASCII diagram showing X, Y, Z axes"
    - "List current body bounds: min/max for each axis"
    - "Calculate exact coordinates for intended operation"
    - "Verify calculation before generating code"

  cadquery_error:
    - "Read the Python traceback carefully"
    - "Identify which CadQuery operation failed"
    - "Check face/edge selectors are valid"
    - "Verify the workplane is correct"
    - "Fix and regenerate the complete code"

  general:
    - "Explain what went wrong in plain language"
    - "Show the problematic code section"
    - "Propose specific fix with reasoning"
    - "Ask user to confirm before applying"

# =============================================================================
# CODE GENERATION STYLE
# =============================================================================
code_style:
  naming:
    - "Use descriptive variable names: 'bolt_hole_dia' not 'd1'"
    - "Use UPPER_CASE for dimension constants"
    - "Use lowercase for intermediate results"

  comments:
    - "Comment the INTENT, not the operation"
    - "Include print orientation notes"
    - "Note any areas that may need supports"

  organization:
    - "Define dimensions as named constants at top"
    - "Group related operations"
    - "Use intermediate variables for complex geometry"
    - "Add wall thickness as a named constant"

  example: |
    import cadquery as cq

    # Phone stand - designed for FDM 3D printing
    # Print orientation: upright (base on print bed)
    # No supports needed with 45-degree back angle

    WALL = 2.0            # mm - wall thickness (5 perimeters)
    BASE_W = 70.0         # mm - base width
    BASE_D = 50.0         # mm - base depth
    BASE_H = 5.0          # mm - base height
    BACK_ANGLE = 45       # degrees - no supports needed

    result = (
        cq.Workplane("XY")
        .box(BASE_W, BASE_D, BASE_H)
        # Flat bottom for good bed adhesion
        .faces(">Z")
        .workplane()
        .rect(BASE_W - 2 * WALL, BASE_D - 2 * WALL)
        .cutBlind(-BASE_H + WALL)
    )

# =============================================================================
# CAPABILITIES & LIMITATIONS
# =============================================================================
capabilities:
  excels_at:
    - "Parametric mechanical parts (brackets, enclosures, gears, flanges)"
    - "Precise geometry with exact dimensions"
    - "Profile-based modeling: sketch 2D shape, then extrude/revolve/sweep/loft"
    - "Boolean operations to build complex shapes from simple primitives"
    - "Patterned features: arrays, mirrors, circular patterns"
    - "Shelling, filleting, chamfering with precise control"
    - "Print-ready models with flat bases and minimal overhangs"
  limitations:
    - "CANNOT create true organic/sculpted surfaces (faces, characters, animals)"
    - "CANNOT do freeform NURBS surface modeling"
    - "Splines are approximate - good for gentle curves, not complex organic shapes"
    - "Very complex boolean operations (>10 bodies) may fail or be slow"
  strategy_for_complex_requests:
    - "ALWAYS break complex shapes into simpler sub-parts"
    - "Use boolean union/cut/intersect to combine sub-parts"
    - "Approximate organic curves with: revolve + polyline profiles, loft between shapes, generous fillets"
    - "For helmet/mask/vehicle shapes: start with spheres/ellipsoids, cut and combine"
    - "If a shape cannot be built, explain the limitation and offer the closest approximation"
    - "Prefer simpler geometry that WORKS over complex geometry that FAILS"
    - "Consider print orientation when designing - minimize overhangs and supports"

# =============================================================================
# ADVANCED TECHNIQUES
# =============================================================================
advanced_techniques:
  profile_based_modeling:
    - "Most complex shapes start as a 2D sketch swept into 3D"
    - "revolve(): Axially symmetric shapes (vases, bowls, domes, wheels)"
    - "sweep(): Profile follows a path (pipes, channels, rails)"
    - "loft(): Smooth blend between different cross-sections"
  approximating_organic_shapes:
    - "Hemispheres: sphere + intersect with half-space box"
    - "Rounded bodies: loft between roundedRect profiles at different heights"
    - "Smooth transitions: large-radius fillets after boolean unions"
    - "Teardrop/egg shapes: revolve a spline profile"
    - "Complex enclosures: loft + shell"
    - "Helmet-like shapes: hemisphere + cylinder extensions + boolean cuts for openings"
  print_specific_techniques:
    - "Design flat bases for bed adhesion"
    - "Use 45-degree chamfers instead of sharp overhangs"
    - "Split tall models into interlocking parts if they exceed build volume"
    - "Add draft angles to vertical walls for easier support removal"
  common_pitfalls:
    - "Fillet radius larger than edge length causes crash - use smaller radius"
    - "Shell on body with thin features causes crash - simplify first"
    - "Boolean operations on non-overlapping bodies do nothing (no error, no effect)"
    - "Revolve profile must be entirely on one side of the axis"
    - "Sweep path must be a Wire object (.wire()), not just edges"
    - "Loft profiles should have same number of segments for clean results"
    - "Apply fillets/chamfers LAST, after all boolean operations"
    - "Shell wall thickness must be >= 1.2mm for printability"

# =============================================================================
# DESIGN THINKING (mandatory pre-generation reasoning)
# =============================================================================
design_thinking:
  mandatory_before_code:
    - "Before writing ANY code, describe the object's geometry in plain English"
    - "List each geometric feature and what CadQuery operation implements it"
    - "Specify approximate dimensions and positions for each feature"
    - "Plan the build sequence (what order to apply operations)"
    - "Identify the base shape that everything else builds upon"

  for_organic_shapes:
    - "Describe the cross-section profile at multiple heights (bottom, middle, top)"
    - "Use revolve() with spline/polyline profiles for axially symmetric parts"
    - "Use loft() between profiles at different heights for varying shapes"
    - "Apply generous fillets (3-8mm) to smooth sharp boolean transitions"
    - "Accept approximation — describe what the closest buildable shape is"
    - "For helmet/mask shapes: use loft between oval profiles, NOT just a sphere with cuts"

  for_complex_objects:
    - "Decompose into major sub-assemblies first (e.g. body, lid, handle)"
    - "For each sub-assembly, identify the base shape and modifications"
    - "Plan boolean operations: which parts get unioned, which get cut"
    - "Verify each cut tool overlaps the target before writing code"
    - "Think about what makes the object RECOGNIZABLE and prioritize those features"

# =============================================================================
# RESPONSE FORMAT
# =============================================================================
response_format:
  on_success:
    - "Brief description of what was created"
    - "The generated CadQuery code in a ```python block"
    - "Print orientation recommendation"
    - "Any areas that may need supports"
    - "Estimated print time range (if applicable)"

  on_clarification_needed:
    - "Explain what information is missing"
    - "Provide 2-3 specific options to choose from"
    - "Default suggestion optimized for 3D printing"

  never:
    - "Never generate code for ambiguous requests without asking"
    - "Never assume dimensions - always ask if not specified"
    - "Never skip printability validation"
    - "Never create geometry with walls thinner than 1.2mm without warning"

# =============================================================================
# CADQUERY COOKBOOK - REFERENCE PATTERNS
# =============================================================================
# Use these as reference for correct CadQuery API usage.
# Each recipe is a self-contained working example.

cookbook:
  - title: "Hollow box (shell operation)"
    description: "Create a box and shell it to make a container with uniform wall thickness"
    code: |
      import cadquery as cq
      W, D, H = 60.0, 40.0, 30.0
      WALL = 2.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .shell(-WALL)
      )

  - title: "Through-cut slot on a wall face"
    description: "Select a specific face and cut a slot that goes all the way through"
    code: |
      import cadquery as cq
      W, D, H = 60.0, 40.0, 30.0
      SLOT_W, SLOT_H = 20.0, 10.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          # Select the front face (+X), place workplane, cut through
          .faces(">X")
          .workplane()
          .rect(SLOT_W, SLOT_H)
          .cutThruAll()
      )

  - title: "Opposing through-slots on two walls"
    description: "Cut matching slots on opposite faces - e.g. entry ports on both short sides of a box"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 40.0, 30.0
      WALL = 2.0
      SLOT_W, SLOT_H = 20.0, 12.0
      # Start with a hollow box
      box = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .shell(-WALL)
      )
      # Cut slot on front face (+X)
      box = (
          box.faces(">X")
          .workplane()
          .rect(SLOT_W, SLOT_H)
          .cutThruAll()
      )
      # Cut slot on back face (-X)
      result = (
          box.faces("<X")
          .workplane()
          .rect(SLOT_W, SLOT_H)
          .cutThruAll()
      )

  - title: "Fillets and chamfers on specific edges"
    description: "Apply fillets or chamfers to selected edges using edge selectors"
    code: |
      import cadquery as cq
      W, D, H = 50.0, 30.0, 20.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          # Fillet only the top edges
          .edges(">Z")
          .fillet(2.0)
          # Chamfer only the bottom edges
          .edges("<Z")
          .chamfer(1.0)
      )

  - title: "Pattern of holes (pushPoints)"
    description: "Create multiple holes at specific positions using pushPoints"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 60.0, 5.0
      HOLE_DIA = 5.5
      # Hole positions as (x, y) tuples on the top face
      HOLE_POS = [(30, 20), (-30, 20), (30, -20), (-30, -20)]
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .workplane()
          .pushPoints(HOLE_POS)
          .hole(HOLE_DIA)
      )

  - title: "Boolean operations (cut, union, intersect)"
    description: "Combine two bodies using boolean cut, union, or intersect"
    code: |
      import cadquery as cq
      # Base plate
      plate = cq.Workplane("XY").box(60, 40, 5)
      # Cylinder to add on top
      boss = cq.Workplane("XY").workplane(offset=5).circle(10).extrude(15)
      # Hole to subtract
      hole = cq.Workplane("XY").circle(4).extrude(20)
      # Union the boss onto the plate, then cut the hole
      result = plate.union(boss).cut(hole)

  - title: "Workplane switching and offsets"
    description: "Work on different planes and at offsets from existing geometry"
    code: |
      import cadquery as cq
      BASE_H = 10.0
      # Base on XY plane
      base = cq.Workplane("XY").box(40, 40, BASE_H)
      # Switch to top face and extrude a smaller block upward
      result = (
          base.faces(">Z")
          .workplane()
          .rect(20, 20)
          .extrude(15)
      )

  - title: "Concentric circles for tubes and rings"
    description: "Create a tube or ring using concentric circles"
    code: |
      import cadquery as cq
      OUTER_R = 20.0
      INNER_R = 16.0
      HEIGHT = 30.0
      result = (
          cq.Workplane("XY")
          .circle(OUTER_R)
          .circle(INNER_R)
          .extrude(HEIGHT)
      )

  - title: "Revolve (wine glass)"
    description: "Create axially symmetric shapes by revolving a polyline profile around an axis"
    code: |
      import cadquery as cq
      # Wine glass profile (half cross-section) - points from bottom to top
      # Profile must be entirely on one side of the revolve axis (positive X here)
      profile_pts = [
          (0, 0),      # center bottom of base
          (30, 0),     # outer edge of base
          (30, 3),     # base thickness
          (3, 3),      # start of stem
          (3, 60),     # top of stem
          (25, 80),    # bowl flare
          (25, 100),   # bowl top outer
          (23, 100),   # bowl top inner (wall thickness)
          (23, 82),    # bowl inner
          (0, 65),     # bowl bottom center
      ]
      result = (
          cq.Workplane("XZ")
          .polyline(profile_pts)
          .close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )

  - title: "Sweep (pipe along path)"
    description: "Sweep a circular profile along a wire path to create a pipe or channel"
    code: |
      import cadquery as cq
      PIPE_RADIUS = 5.0
      # Create a path using a series of points with arcs
      path = (
          cq.Workplane("XZ")
          .moveTo(0, 0)
          .lineTo(0, 30)
          .threePointArc((15, 45), (30, 45))
          .lineTo(60, 45)
          .wire()
      )
      # Sweep a circle along the path
      result = (
          cq.Workplane("XY")
          .circle(PIPE_RADIUS)
          .sweep(path)
      )

  - title: "Loft (square to circle transition)"
    description: "Smooth blend between different cross-section shapes at different heights"
    code: |
      import cadquery as cq
      # Bottom profile: 40x40 rounded rectangle
      bottom = cq.Workplane("XY").rect(40, 40)
      # Top profile: circle at Z=50
      top = cq.Workplane("XY").workplane(offset=50).circle(15)
      # Loft between the two profiles
      result = bottom.loft(top)

  - title: "Spline curves (ergonomic shape)"
    description: "Use splines for smooth organic-ish curves, then revolve for 3D shape"
    code: |
      import cadquery as cq
      # Spline profile for an egg/teardrop shape (revolve around Y axis)
      spline_pts = [
          (0, 0),
          (12, 10),
          (18, 25),
          (15, 45),
          (8, 55),
          (0, 60),
      ]
      result = (
          cq.Workplane("XZ")
          .spline(spline_pts)
          .close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )

  - title: "Advanced edge selectors"
    description: "Select edges by direction, position, and compound filters"
    code: |
      import cadquery as cq
      W, D, H = 60.0, 40.0, 30.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          # '|Z' selects edges parallel to Z axis (vertical edges)
          .edges("|Z")
          .fillet(3.0)
          # '>Z' selects edges at the maximum Z (top edges)
          .edges(">Z")
          .chamfer(1.0)
      )

  - title: "Shell with face removal and ports"
    description: "Create a hollow enclosure by shelling then cutting access ports"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 50.0, 40.0
      WALL = 2.5
      PORT_DIA = 15.0
      # Shell removes material from inside, opening the selected face
      enclosure = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .shell(-WALL)
      )
      # Cut a circular port on the front face
      result = (
          enclosure.faces(">X")
          .workplane()
          .hole(PORT_DIA)
      )

  - title: "Complex boolean composition (helmet shape)"
    description: "Build complex shapes from simple primitives using boolean operations"
    code: |
      import cadquery as cq
      R = 50.0       # head radius
      WALL = 3.0     # shell thickness
      VISOR_W = 60.0
      VISOR_H = 25.0

      # Start with a sphere
      sphere = cq.Workplane("XY").sphere(R)
      # Cut bottom half to get hemisphere (dome)
      cut_box = cq.Workplane("XY").box(R * 3, R * 3, R).translate((0, 0, -R / 2))
      dome = sphere.cut(cut_box)
      # Extend downward with a cylinder for the jaw area
      jaw = cq.Workplane("XY").circle(R).extrude(-20)
      helmet_solid = dome.union(jaw)
      # Shell it to make it hollow
      helmet = helmet_solid.shell(-WALL)
      # Cut visor opening on front face
      visor_cut = (
          cq.Workplane("XZ")
          .workplane(offset=R)
          .rect(VISOR_W, VISOR_H)
          .extrude(-WALL * 3)
      )
      result = helmet.cut(visor_cut)

  - title: "Circular pattern (polar array of holes)"
    description: "Create features arranged in a circular pattern using polarArray"
    code: |
      import cadquery as cq
      DISC_R = 40.0
      DISC_H = 8.0
      HOLE_DIA = 6.0
      HOLE_CIRCLE_R = 30.0
      NUM_HOLES = 6

      result = (
          cq.Workplane("XY")
          .circle(DISC_R)
          .extrude(DISC_H)
          .faces(">Z")
          .workplane()
          .polarArray(HOLE_CIRCLE_R, 0, 360, NUM_HOLES)
          .hole(HOLE_DIA)
      )

  - title: "Text embossing on a face"
    description: "Add raised or engraved text to a face of a solid"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 30.0, 5.0
      FONT_SIZE = 10.0
      TEXT_DEPTH = 1.0   # positive = raised, negative would need .cutBlind

      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .workplane()
          .text("HELLO", FONT_SIZE, TEXT_DEPTH)
      )

  - title: "Rounded enclosure (loft between rounded rectangles)"
    description: "Create a smooth enclosure by lofting between rounded rectangles at different heights"
    code: |
      import cadquery as cq
      W_BOT, D_BOT = 60.0, 40.0  # bottom dimensions
      W_TOP, D_TOP = 50.0, 35.0  # top dimensions (slightly smaller)
      HEIGHT = 30.0
      CORNER_R = 5.0
      WALL = 2.0

      # Bottom profile
      bottom = cq.Workplane("XY").rect(W_BOT, D_BOT).val()
      # Top profile
      top = cq.Workplane("XY").workplane(offset=HEIGHT).rect(W_TOP, D_TOP).val()
      # Loft and shell
      result = (
          cq.Workplane("XY")
          .rect(W_BOT, D_BOT)
          .workplane(offset=HEIGHT)
          .rect(W_TOP, D_TOP)
          .loft()
          .edges("|Z")
          .fillet(CORNER_R)
          .faces(">Z")
          .shell(-WALL)
      )

  - title: "Countersink and counterbore holes"
    description: "Create standard countersink (cskHole) and counterbore (cboreHole) holes for fasteners"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 40.0, 10.0

      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .workplane()
          # Counterbore hole: hole_dia, cbore_dia, cbore_depth
          .pushPoints([(-20, 0)])
          .cboreHole(5.0, 10.0, 3.0)
          # Countersink hole: hole_dia, csk_dia, csk_angle (82 or 90 deg typical)
          .pushPoints([(20, 0)])
          .cskHole(5.0, 10.0, 82)
      )

  - title: "Multi-body workflow (separate parts combined)"
    description: "Build complex models from separate bodies using translate and boolean union"
    code: |
      import cadquery as cq
      # Body 1: base plate
      base = cq.Workplane("XY").box(80, 60, 5)
      # Body 2: left pillar
      pillar_l = (
          cq.Workplane("XY")
          .workplane(offset=5)
          .center(-30, 0)
          .circle(8)
          .extrude(40)
      )
      # Body 3: right pillar
      pillar_r = (
          cq.Workplane("XY")
          .workplane(offset=5)
          .center(30, 0)
          .circle(8)
          .extrude(40)
      )
      # Body 4: top bridge
      bridge = cq.Workplane("XY").workplane(offset=45).box(76, 16, 5)
      # Combine all parts, then fillet the joints
      combined = base.union(pillar_l).union(pillar_r).union(bridge)
      # Apply fillets LAST after all booleans
      result = combined.edges("|Z").fillet(2.0)

  - title: "Helmet shape via multi-height loft + boolean cuts"
    description: "Build a helmet-like shape by lofting between oval profiles at different heights, then cutting visor and mouth openings. Much better than sphere + cuts."
    code: |
      import cadquery as cq

      # Helmet dimensions
      H_WIDTH = 180.0    # side to side
      H_DEPTH = 220.0    # front to back
      H_HEIGHT = 200.0   # bottom to top
      WALL = 4.0

      # Build helmet shell by lofting oval profiles at different heights
      helmet = (
          cq.Workplane("XY")
          .ellipse(H_WIDTH / 2, H_DEPTH / 2)
          .workplane(offset=H_HEIGHT * 0.4)
          .ellipse(H_WIDTH / 2 * 1.05, H_DEPTH / 2 * 1.05)
          .workplane(offset=H_HEIGHT * 0.35)
          .ellipse(H_WIDTH / 2 * 0.85, H_DEPTH / 2 * 0.9)
          .workplane(offset=H_HEIGHT * 0.25)
          .ellipse(H_WIDTH / 2 * 0.4, H_DEPTH / 2 * 0.5)
          .loft()
      )
      helmet = helmet.faces("<Z").shell(-WALL)

      VISOR_W = 140.0
      VISOR_H = 40.0
      VISOR_Z = H_HEIGHT * 0.55
      visor_cutter = (
          cq.Workplane("XZ")
          .center(0, VISOR_Z)
          .rect(VISOR_W, VISOR_H)
          .extrude(H_DEPTH)
      )
      helmet = helmet.cut(visor_cutter)

      MOUTH_W = 60.0
      MOUTH_H = 15.0
      MOUTH_Z = H_HEIGHT * 0.3
      mouth_cutter = (
          cq.Workplane("XZ")
          .center(0, MOUTH_Z)
          .rect(MOUTH_W, MOUTH_H)
          .extrude(H_DEPTH)
      )
      helmet = helmet.cut(mouth_cutter)
      result = helmet.edges().fillet(2.0)

  - title: "Ergonomic handle via revolve with spline profile"
    description: "Create a grip/handle shape using revolve with a spline profile curve."
    code: |
      import cadquery as cq

      PROFILE_PTS = [
          (0, 0), (12, 0), (14, 10), (16, 30), (15, 50),
          (12, 70), (8, 90), (10, 100), (10, 105), (0, 105),
      ]

      handle_profile = (
          cq.Workplane("XZ")
          .moveTo(*PROFILE_PTS[0])
      )
      handle_profile = handle_profile.spline(PROFILE_PTS[1:], includeCurrent=True)
      handle_profile = handle_profile.close()
      result = handle_profile.revolve(360, (0, 0, 0), (0, 0, 1))

  - title: "Phone case using loft + shell + boolean cuts for ports"
    description: "Build a phone case shape by lofting rounded rectangles, shelling, then cutting openings."
    code: |
      import cadquery as cq

      PH_W = 75.0
      PH_D = 155.0
      PH_T = 10.0
      WALL = 1.5
      CORNER_R = 8.0

      case_body = (
          cq.Workplane("XY")
          .rect(PH_W, PH_D)
          .workplane(offset=PH_T)
          .rect(PH_W + 1.0, PH_D + 1.0)
          .loft()
          .edges("|Z")
          .fillet(CORNER_R)
      )
      case_body = case_body.faces(">Z").shell(-WALL)

      CAM_X = -PH_W / 2 + 20.0
      CAM_Y = PH_D / 2 - 25.0
      cam_cutter = (
          cq.Workplane("XY")
          .center(CAM_X, CAM_Y)
          .rect(30.0, 35.0)
          .extrude(-WALL * 2)
      )
      case_body = case_body.cut(cam_cutter)

      port_cutter = (
          cq.Workplane("XZ")
          .workplane(offset=-PH_D / 2)
          .rect(15.0, 5.0)
          .extrude(-WALL * 2)
      )
      result = case_body.cut(port_cutter)

  # --- Phase 1.1: Expanded Recipes (25 new) ---

  # A. Plumbing & Fluid

  - title: "Pipe elbow (90-degree swept bend)"
    description: "Sweep a circular profile along a 90-degree arc to create a pipe elbow"
    code: |
      import cadquery as cq
      PIPE_OD = 20.0
      PIPE_WALL = 2.0
      BEND_R = 40.0  # center-line bend radius
      # 90-degree arc path in XZ plane
      path = (
          cq.Workplane("XZ")
          .radiusArc((BEND_R, BEND_R), -BEND_R)
          .wire()
      )
      # Sweep annular profile (outer - inner circle)
      result = (
          cq.Workplane("XY")
          .circle(PIPE_OD / 2)
          .circle(PIPE_OD / 2 - PIPE_WALL)
          .sweep(path)
      )

  - title: "Pipe T-junction"
    description: "Create a hollow T-junction from outer and inner cylinder booleans (shell on complex unions is unreliable)"
    code: |
      import cadquery as cq
      OD = 20.0
      WALL = 2.0
      ID = OD - 2 * WALL
      LENGTH = 60.0
      BRANCH_L = 40.0
      # Outer solid T-shape
      main_outer = cq.Workplane("XY").circle(OD / 2).extrude(LENGTH).translate((0, 0, -LENGTH / 2))
      branch_outer = cq.Workplane("XZ").circle(OD / 2).extrude(BRANCH_L)
      outer = main_outer.union(branch_outer)
      # Inner void T-shape (slightly longer to ensure clean cut)
      main_inner = cq.Workplane("XY").circle(ID / 2).extrude(LENGTH + 2).translate((0, 0, -LENGTH / 2 - 1))
      branch_inner = cq.Workplane("XZ").circle(ID / 2).extrude(BRANCH_L + 1)
      inner = main_inner.union(branch_inner)
      result = outer.cut(inner)

  # B. Fasteners & Hardware

  - title: "Hex bolt (simplified, no threads)"
    description: "Hex head polygon extruded + cylindrical shaft with chamfered tip. No real threads — helix sweep is unreliable in CadQuery."
    code: |
      import cadquery as cq
      # M8 approximate dimensions
      HEAD_AF = 13.0   # across-flats (wrench size)
      HEAD_H = 5.3
      SHAFT_D = 8.0
      SHAFT_L = 30.0
      # Hex head: inscribed polygon (6 sides)
      head = (
          cq.Workplane("XY")
          .polygon(6, HEAD_AF)
          .extrude(HEAD_H)
      )
      # Shaft below head
      shaft = (
          cq.Workplane("XY")
          .circle(SHAFT_D / 2)
          .extrude(-SHAFT_L)
      )
      result = (
          head.union(shaft)
          .edges("<Z")
          .chamfer(0.8)
      )

  - title: "Compression spring (helix sweep)"
    description: "Sweep a small circle along a helix path to create a compression spring"
    code: |
      import cadquery as cq
      WIRE_DIA = 2.0
      COIL_OD = 20.0
      PITCH = 6.0
      N_COILS = 5
      HEIGHT = PITCH * N_COILS
      COIL_R = (COIL_OD - WIRE_DIA) / 2
      # Create helix path
      helix = cq.Wire.makeHelix(PITCH, HEIGHT, COIL_R)
      # Sweep wire cross-section along helix
      result = (
          cq.Workplane("XZ")
          .center(COIL_R, 0)
          .circle(WIRE_DIA / 2)
          .sweep(helix, isFrenet=True)
      )

  - title: "Standoff / spacer with hex base"
    description: "Hex base polygon + hollow cylindrical body + through-hole for a screw"
    code: |
      import cadquery as cq
      HEX_AF = 8.0     # across-flats
      HEX_H = 3.0
      BODY_OD = 6.0
      BODY_H = 10.0
      BORE_D = 3.2     # M3 clearance
      # Hex base
      base = cq.Workplane("XY").polygon(6, HEX_AF).extrude(HEX_H)
      # Round body on top
      body = cq.Workplane("XY").workplane(offset=HEX_H).circle(BODY_OD / 2).extrude(BODY_H)
      # Union, then drill through-hole
      result = (
          base.union(body)
          .faces(">Z").workplane()
          .hole(BORE_D)
      )

  - title: "Bearing seat (revolved stepped bore)"
    description: "Revolve a stepped bore profile with shoulder and snap-ring groove for a bearing housing"
    code: |
      import cadquery as cq
      # Profile (half cross-section) for revolve around Z axis
      # OD=40, bearing bore=22, shoulder, snap-ring groove
      pts = [
          (0, 0), (20, 0), (20, 5),           # bottom flange
          (16, 5), (16, 8),                     # step to bore
          (11, 8), (11, 25),                    # bearing bore wall
          (12, 25), (12, 27), (11, 27),         # snap-ring groove
          (11, 30), (20, 30), (20, 35),         # top flange
          (0, 35),                              # top center
      ]
      result = (
          cq.Workplane("XZ")
          .polyline(pts)
          .close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )

  # C. Joints & Connections

  - title: "Snap-fit hook (cantilever with barb)"
    description: "A cantilever arm with an angled barb tip, extruded from a polyline profile"
    code: |
      import cadquery as cq
      ARM_L = 15.0
      ARM_T = 1.5
      ARM_W = 5.0
      BARB_H = 2.0
      BARB_ANGLE_RUN = 1.5  # horizontal run of barb slope
      BASE_H = 5.0
      # Side profile of snap-fit hook (XZ plane)
      pts = [
          (0, 0), (ARM_T, 0), (ARM_T, BASE_H),         # base block
          (ARM_T, BASE_H + ARM_L),                       # arm tip
          (ARM_T + BARB_ANGLE_RUN, BASE_H + ARM_L + BARB_H),  # barb peak
          (ARM_T, BASE_H + ARM_L + BARB_H),             # barb inner
          (0, BASE_H + ARM_L + BARB_H),                 # back of barb
          (0, BASE_H),                                   # back to base top
      ]
      result = (
          cq.Workplane("XZ")
          .polyline(pts)
          .close()
          .extrude(ARM_W)
      )

  - title: "Snap-fit clip (U-shaped with detent bumps)"
    description: "U-shaped clip body with small detent bumps on inner arms for push-fit retention"
    code: |
      import cadquery as cq
      W = 12.0      # overall width
      H = 15.0      # arm height
      T = 1.5       # wall thickness
      GAP = 6.0     # inner gap
      DEPTH = 8.0   # extrusion depth
      BUMP_R = 0.8
      # U-shape profile
      pts = [
          (0, 0), (W, 0), (W, H),
          (W - T, H), (W - T, T), (T, T),
          (T, H), (0, H),
      ]
      clip = (
          cq.Workplane("XZ")
          .polyline(pts)
          .close()
          .extrude(DEPTH)
      )
      # Add detent bumps on inner faces of arms
      bump_l = cq.Workplane("XY").workplane(offset=H * 0.7).center(T, DEPTH / 2).sphere(BUMP_R)
      bump_r = cq.Workplane("XY").workplane(offset=H * 0.7).center(W - T, DEPTH / 2).sphere(BUMP_R)
      result = clip.union(bump_l).union(bump_r)

  - title: "Dovetail joint (male and female pieces)"
    description: "Trapezoidal male dovetail piece and matching female block with trapezoidal cutout"
    code: |
      import cadquery as cq
      # Dovetail cross-section (trapezoid)
      BASE_W = 10.0
      TOP_W = 14.0
      DT_H = 8.0
      LENGTH = 40.0
      BLOCK = 30.0
      # Male dovetail piece
      tail_pts = [
          (-BASE_W / 2, 0), (BASE_W / 2, 0),
          (TOP_W / 2, DT_H), (-TOP_W / 2, DT_H),
      ]
      male = (
          cq.Workplane("XZ")
          .polyline(tail_pts).close()
          .extrude(LENGTH)
      )
      # Female piece: block with dovetail slot cut through
      block = cq.Workplane("XY").box(BLOCK, LENGTH, BLOCK)
      slot_cutter = (
          cq.Workplane("XZ")
          .polyline(tail_pts).close()
          .extrude(LENGTH * 1.1)
          .translate((0, -LENGTH * 0.05, 0))
      )
      female = block.cut(slot_cutter)
      # Return male piece (change to female if needed)
      result = male

  - title: "Finger joint (box joint)"
    description: "Two interlocking boards with rectangular finger tabs cut in a loop"
    code: |
      import cadquery as cq
      BOARD_W = 60.0
      BOARD_H = 40.0
      BOARD_T = 5.0
      N_FINGERS = 5
      FINGER_W = BOARD_W / (N_FINGERS * 2 + 1)
      # Board A: fingers at even positions
      board_a = cq.Workplane("XY").box(BOARD_W, BOARD_T, BOARD_H)
      for i in range(N_FINGERS):
          x_pos = -BOARD_W / 2 + FINGER_W * (2 * i + 1) + FINGER_W / 2
          cutter = (
              cq.Workplane("XY")
              .center(x_pos, 0)
              .rect(FINGER_W, BOARD_T * 2)
              .extrude(BOARD_T)
              .translate((0, 0, -BOARD_T / 2))
          )
          board_a = board_a.cut(cutter)
      result = board_a

  # D. Brackets & Structural

  - title: "L-bracket with gusset and mounting holes"
    description: "L-profile from polyline extrude, triangular gusset for stiffness, and mounting holes"
    code: |
      import cadquery as cq
      W = 40.0      # width (extrusion)
      LEG = 50.0    # leg lengths
      T = 4.0       # thickness
      HOLE_D = 5.5  # M5 clearance
      # L-profile
      l_pts = [
          (0, 0), (LEG, 0), (LEG, T),
          (T, T), (T, LEG), (0, LEG),
      ]
      bracket = cq.Workplane("XZ").polyline(l_pts).close().extrude(W)
      # Triangular gusset
      gusset_pts = [(T, T), (T + 15, T), (T, T + 15)]
      gusset = (
          cq.Workplane("XZ").polyline(gusset_pts).close()
          .extrude(W * 0.3).translate((0, W * 0.35, 0))
      )
      bracket = bracket.union(gusset)
      # Mounting holes on horizontal leg
      bracket = (
          bracket.faces("<Z").workplane()
          .pushPoints([(20, W / 2 - 10), (40, W / 2 - 10)])
          .hole(HOLE_D)
      )
      result = bracket

  - title: "Shelf bracket (triangular plate with fillet)"
    description: "Triangular bracket plate from polyline profile with fillet and two mounting holes"
    code: |
      import cadquery as cq
      ARM_H = 80.0   # vertical arm
      ARM_W = 60.0   # horizontal arm
      T = 5.0         # thickness
      HOLE_D = 6.0
      FILLET_R = 15.0
      # Triangular profile
      pts = [(0, 0), (ARM_W, 0), (0, ARM_H)]
      bracket = (
          cq.Workplane("XZ")
          .polyline(pts).close()
          .extrude(T)
      )
      # Fillet the hypotenuse edge (longest edge at mid-height)
      bracket = bracket.edges("|Y").fillet(FILLET_R)
      # Mounting holes on the vertical leg
      result = (
          bracket.faces("<X").workplane()
          .pushPoints([(T / 2, 15), (T / 2, ARM_H - 15)])
          .hole(HOLE_D)
      )

  # E. Enclosures & Cases

  - title: "Electronics enclosure with standoffs"
    description: "Rectangular box with shell, corner standoff cylinders, and screw holes"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 60.0, 30.0
      WALL = 2.0
      STANDOFF_D = 6.0
      STANDOFF_H = 5.0
      SCREW_D = 2.5   # M2.5
      # Shell the box
      enclosure = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .shell(-WALL)
      )
      # Corner standoff positions (inset from corners)
      INSET = 6.0
      corners = [
          (W / 2 - INSET, D / 2 - INSET),
          (-W / 2 + INSET, D / 2 - INSET),
          (W / 2 - INSET, -D / 2 + INSET),
          (-W / 2 + INSET, -D / 2 + INSET),
      ]
      # Add standoff cylinders on inside floor
      standoffs = cq.Workplane("XY").workplane(offset=WALL)
      for cx, cy in corners:
          post = cq.Workplane("XY").workplane(offset=WALL).center(cx, cy).circle(STANDOFF_D / 2).extrude(STANDOFF_H)
          enclosure = enclosure.union(post)
      # Drill screw holes through standoffs
      result = (
          enclosure.faces(">Z").workplane(offset=-H + WALL + STANDOFF_H)
          .pushPoints(corners)
          .hole(SCREW_D)
      )

  - title: "Raspberry Pi case (real dimensions)"
    description: "92x63x25mm case with shell, USB-C / HDMI / SD card cutouts, and standoffs at Pi mounting holes"
    code: |
      import cadquery as cq
      # Pi 5 approximate board + case dims
      W, D, H = 92.0, 63.0, 25.0
      WALL = 2.0
      # Standoff positions (Pi mounting holes, relative to center)
      MOUNTS = [(24.5, 24.5), (-24.5, 24.5), (24.5, -24.5), (-24.5, -24.5)]
      case = (
          cq.Workplane("XY").box(W, D, H)
          .edges("|Z").fillet(3.0)
          .faces(">Z").shell(-WALL)
      )
      # Add standoffs
      for mx, my in MOUNTS:
          post = cq.Workplane("XY").workplane(offset=WALL).center(mx, my).circle(3.0).extrude(4.0)
          case = case.union(post)
      # USB-C cutout on front face
      case = case.faces(">X").workplane().center(0, -3).rect(9.0, 3.5).cutBlind(-WALL * 2)
      # Micro-HDMI cutout
      case = case.faces(">X").workplane().center(-15, -3).rect(7.5, 3.5).cutBlind(-WALL * 2)
      # SD card slot on left side
      case = case.faces("<Y").workplane().center(10, -3).rect(14.0, 2.5).cutBlind(-WALL * 2)
      result = case

  - title: "Battery holder (AA size)"
    description: "Rectangular cavity sized for AA battery with end clips and terminal contact slots"
    code: |
      import cadquery as cq
      # AA battery: 14.5mm dia x 50.5mm length
      BAT_D = 14.5
      BAT_L = 50.5
      WALL = 2.0
      CLIP_T = 1.0
      CLIP_H = 8.0
      SLOT_W = 4.0
      # Outer box around battery
      OW = BAT_D + WALL * 2
      OD = BAT_L + WALL * 2 + 4.0  # extra for spring contact
      OH = BAT_D / 2 + WALL + 2.0
      holder = cq.Workplane("XY").box(OW, OD, OH)
      # Cavity for battery (cylindrical)
      cavity = (
          cq.Workplane("YZ")
          .center(0, WALL + BAT_D / 2)
          .circle(BAT_D / 2 + 0.3)  # clearance
          .extrude(BAT_L + 2.0)
          .translate((0, -BAT_L / 2 - 1.0, 0))
      )
      holder = holder.cut(cavity)
      # Terminal slots on both ends
      slot1 = cq.Workplane("XY").box(SLOT_W, WALL * 2, CLIP_H).translate((0, OD / 2, CLIP_H / 2))
      slot2 = cq.Workplane("XY").box(SLOT_W, WALL * 2, CLIP_H).translate((0, -OD / 2, CLIP_H / 2))
      result = holder.cut(slot1).cut(slot2)

  # F. Rotational Parts

  - title: "Spur gear (simplified involute)"
    description: "Simplified spur gear with 12 teeth using polyline tooth profile and polarArray, plus center bore"
    code: |
      import cadquery as cq
      import math
      N_TEETH = 12
      MODULE = 2.5
      FACE_W = 8.0
      BORE_D = 10.0
      PD = MODULE * N_TEETH       # pitch diameter
      OD = PD + 2 * MODULE        # outer diameter
      RD = PD - 2.5 * MODULE      # root diameter
      TOOTH_ARC = 360.0 / N_TEETH
      HALF_T = TOOTH_ARC / 4      # half tooth angular width in degrees
      # Build a single tooth profile (simplified trapezoidal)
      r_root = RD / 2
      r_pitch = PD / 2
      r_tip = OD / 2
      a = math.radians(HALF_T)
      tooth_pts = [
          (r_root * math.cos(-a * 1.2), r_root * math.sin(-a * 1.2)),
          (r_tip * math.cos(-a * 0.4), r_tip * math.sin(-a * 0.4)),
          (r_tip * math.cos(a * 0.4), r_tip * math.sin(a * 0.4)),
          (r_root * math.cos(a * 1.2), r_root * math.sin(a * 1.2)),
      ]
      # Root circle disc
      gear = cq.Workplane("XY").circle(r_root).extrude(FACE_W)
      # Add one tooth and pattern it
      tooth = cq.Workplane("XY").polyline(tooth_pts).close().extrude(FACE_W)
      for i in range(N_TEETH):
          angle = i * TOOTH_ARC
          rotated = tooth.rotate((0, 0, 0), (0, 0, 1), angle)
          gear = gear.union(rotated)
      # Center bore
      result = gear.faces(">Z").workplane().hole(BORE_D)

  - title: "Pulley wheel (revolve with V-groove)"
    description: "Revolve a profile with a V-groove to create a pulley wheel with center bore"
    code: |
      import cadquery as cq
      OD = 50.0
      W = 15.0
      GROOVE_D = 8.0
      GROOVE_ANGLE_W = 6.0
      BORE_D = 10.0
      HUB_D = 20.0
      # Half cross-section profile for revolve
      pts = [
          (BORE_D / 2, 0), (OD / 2, 0), (OD / 2, W * 0.3),
          (OD / 2 - GROOVE_D, W / 2),  # groove bottom
          (OD / 2, W * 0.7), (OD / 2, W),
          (BORE_D / 2, W),
      ]
      result = (
          cq.Workplane("XZ")
          .polyline(pts).close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
          .faces(">Z").workplane()
          .hole(BORE_D)
      )

  - title: "Cam profile (eccentric revolve)"
    description: "Revolve an eccentric profile to create a cam with shaft bore"
    code: |
      import cadquery as cq
      CAM_R = 25.0    # max radius
      CAM_MIN = 15.0  # min radius
      THICKNESS = 10.0
      BORE_D = 8.0
      # Build cam using offset circle (eccentric disc)
      ECCENTRICITY = (CAM_R - CAM_MIN) / 2
      MEAN_R = (CAM_R + CAM_MIN) / 2
      cam = (
          cq.Workplane("XY")
          .center(ECCENTRICITY, 0)
          .circle(MEAN_R)
          .extrude(THICKNESS)
      )
      # Bore at true center (0,0)
      bore = cq.Workplane("XY").circle(BORE_D / 2).extrude(THICKNESS)
      result = cam.cut(bore)

  # G. Hinge & Flexure

  - title: "Pin hinge (two plates with knuckles)"
    description: "Two plates with alternating cylinder knuckles (3 total) sharing a common pin hole"
    code: |
      import cadquery as cq
      PLATE_W = 30.0
      PLATE_L = 40.0
      PLATE_T = 3.0
      KNUCKLE_R = 4.0
      KNUCKLE_L = 10.0
      PIN_D = 3.0
      # Left plate with 2 knuckles at positions 0 and 2
      plate_l = cq.Workplane("XY").box(PLATE_W, PLATE_L, PLATE_T)
      for i in [0, 2]:
          k = (
              cq.Workplane("XZ")
              .workplane(offset=PLATE_L / 2)
              .center(0, PLATE_T)
              .circle(KNUCKLE_R)
              .extrude(KNUCKLE_L)
              .translate((0, -i * KNUCKLE_L, 0))
          )
          plate_l = plate_l.union(k)
      # Right plate with 1 knuckle at position 1
      plate_r = cq.Workplane("XY").box(PLATE_W, PLATE_L, PLATE_T).translate((PLATE_W + 2, 0, 0))
      k_mid = (
          cq.Workplane("XZ")
          .workplane(offset=PLATE_L / 2)
          .center(0, PLATE_T)
          .circle(KNUCKLE_R)
          .extrude(KNUCKLE_L)
          .translate((PLATE_W + 2, -KNUCKLE_L, 0))
      )
      plate_r = plate_r.union(k_mid)
      # Return left plate (both plates shown separately)
      result = plate_l

  - title: "Living hinge (thin flexure bridge)"
    description: "Two rigid blocks connected by a thin (0.4mm) flexure bridge for fold-over hinge"
    code: |
      import cadquery as cq
      BLOCK_W = 40.0
      BLOCK_D = 30.0
      BLOCK_H = 5.0
      HINGE_T = 0.4    # thin flex section
      HINGE_L = 2.0    # length of flex zone
      GAP = HINGE_L
      # Left block
      left = cq.Workplane("XY").box(BLOCK_W, BLOCK_D, BLOCK_H)
      # Right block offset by gap
      right = cq.Workplane("XY").box(BLOCK_W, BLOCK_D, BLOCK_H).translate((BLOCK_W + GAP, 0, 0))
      # Thin bridge connecting them at top surface
      bridge = (
          cq.Workplane("XY")
          .workplane(offset=BLOCK_H / 2 - HINGE_T)
          .center(BLOCK_W / 2 + GAP / 2, 0)
          .rect(GAP + 2, BLOCK_D)
          .extrude(HINGE_T)
      )
      result = left.union(right).union(bridge)

  # H. Surface Features & Cutouts

  - title: "Knurled grip (simplified circumferential grooves)"
    description: "Cylinder with circumferential V-grooves via polarArray of small cuts for grip texture"
    code: |
      import cadquery as cq
      GRIP_D = 25.0
      GRIP_H = 40.0
      N_GROOVES = 24
      GROOVE_DEPTH = 1.0
      GROOVE_W = 1.5
      # Solid cylinder
      grip = cq.Workplane("XY").circle(GRIP_D / 2).extrude(GRIP_H)
      # Cut vertical grooves arranged radially
      groove = (
          cq.Workplane("XY")
          .center(GRIP_D / 2, 0)
          .rect(GROOVE_DEPTH * 2, GROOVE_W)
          .extrude(GRIP_H)
      )
      for i in range(N_GROOVES):
          angle = i * (360.0 / N_GROOVES)
          rotated = groove.rotate((0, 0, 0), (0, 0, 1), angle)
          grip = grip.cut(rotated)
      result = grip

  - title: "USB-C port cutout"
    description: "Panel plate with a USB-C shaped rounded-rectangle cutout (8.94 x 3.26mm, R=1.0)"
    code: |
      import cadquery as cq
      PANEL_W = 40.0
      PANEL_H = 30.0
      PANEL_T = 2.0
      USB_W = 8.94
      USB_H = 3.26
      USB_R = 1.0  # corner radius
      result = (
          cq.Workplane("XY")
          .box(PANEL_W, PANEL_H, PANEL_T)
          .faces(">Z").workplane()
          .slot2D(USB_W, USB_H)
          .cutThruAll()
      )

  - title: "D-sub connector cutout (DE-9)"
    description: "Panel plate with trapezoidal D-sub cutout using real DE-9 dimensions (17.7 x 10.0mm)"
    code: |
      import cadquery as cq
      PANEL_W = 50.0
      PANEL_H = 30.0
      PANEL_T = 2.0
      # DE-9 D-sub approximate outline (trapezoidal)
      TOP_W = 16.0
      BOT_W = 12.5
      D_H = 10.0
      # Trapezoidal cutout profile
      trap_pts = [
          (-BOT_W / 2, -D_H / 2),
          (BOT_W / 2, -D_H / 2),
          (TOP_W / 2, D_H / 2),
          (-TOP_W / 2, D_H / 2),
      ]
      panel = cq.Workplane("XY").box(PANEL_W, PANEL_H, PANEL_T)
      cutout = (
          cq.Workplane("XY")
          .workplane(offset=PANEL_T)
          .polyline(trap_pts).close()
          .extrude(-PANEL_T * 2)
      )
      result = panel.cut(cutout)

  # I. Small Items

  - title: "Cable gland / grommet (revolved stepped profile)"
    description: "Revolve a stepped profile to create a cable gland with flange, body, and bore"
    code: |
      import cadquery as cq
      # Profile: flange + body + thread-like steps
      BORE_R = 4.0
      BODY_R = 8.0
      FLANGE_R = 12.0
      pts = [
          (BORE_R, 0), (FLANGE_R, 0), (FLANGE_R, 3),   # flange
          (BODY_R, 3), (BODY_R, 7),                      # neck
          (BODY_R + 1, 7), (BODY_R + 1, 9),              # step/ridge
          (BODY_R, 9), (BODY_R, 18),                     # body
          (BORE_R, 18),                                   # top bore
      ]
      result = (
          cq.Workplane("XZ")
          .polyline(pts).close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )

  - title: "Keychain tag (rounded plate + text + ring hole)"
    description: "Rounded rectangle plate with embossed text and a ring attachment hole"
    code: |
      import cadquery as cq
      TAG_W = 50.0
      TAG_H = 25.0
      TAG_T = 3.0
      CORNER_R = 5.0
      RING_HOLE_D = 5.0
      tag = (
          cq.Workplane("XY")
          .rect(TAG_W, TAG_H)
          .extrude(TAG_T)
          .edges("|Z").fillet(CORNER_R)
      )
      # Ring hole on one end
      tag = tag.faces(">Z").workplane().center(-TAG_W / 2 + 8, 0).hole(RING_HOLE_D)
      # Text on top face
      result = tag.faces(">Z").workplane().center(5, 0).text("TAG", 8.0, 0.5)
