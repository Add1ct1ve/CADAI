# CAD AI Studio - CNC Machining Focused Agent Rules
# Optimized for 3-axis CNC milling with strict manufacturability constraints

version: 1

# =============================================================================
# COORDINATE SYSTEM
# =============================================================================
coordinate_system:
  description: "Right-hand coordinate system (machining convention)"
  x:
    direction: "length / left-right on table"
    positive: "right"
  y:
    direction: "depth / front-back on table"
    positive: "toward operator"
  z:
    direction: "height / spindle axis"
    positive: "up (away from table)"
  origin: "center of top face (machining datum surface)"

# =============================================================================
# SPATIAL REASONING RULES
# =============================================================================
spatial_rules:
  before_any_operation:
    - "Mentally visualize the current state of the model"
    - "Identify which faces/edges the operation targets"
    - "Verify operation will intersect existing geometry"
    - "Consider tool access - can the end mill reach this feature?"

  boolean_cut:
    - "The cutting tool MUST overlap the target body"
    - "Position cutting tool so it extends BEYOND the target surface"
    - "Use .cut() or .cutBlind() with sufficient depth"
    - "Verify the cut is accessible from the spindle direction"

  boolean_fuse:
    - "Bodies MUST touch or overlap to fuse"
    - "Verify no air gap between bodies"

  extrude:
    - "Positive height = extrude in +Z direction"
    - "Negative height = extrude in -Z direction"
    - "Always specify direction explicitly if not along Z"

  sketch_placement:
    - "XY plane = top face (tool approaches from +Z)"
    - "XZ plane = front face (Y=0)"
    - "YZ plane = side face (X=0)"
    - "Use .faces('>Z') to select top face for next operation"
    - "Use .faces('<Z') to select bottom face"

  natural_language_to_axis:
    - "upper / lower / top / bottom / above / below → Z axis (spindle axis)"
    - "left / right → X axis (table left-right)"
    - "front / back / forward / backward → Y axis (table front-back)"
    - "taller / shorter → Z dimension"
    - "wider / narrower → X dimension"
    - "deeper / shallower → Y dimension"

  splitting_and_halving:
    - "CRITICAL: 'cut in half' means bisect the object along the CENTER of the relevant axis"
    - "'top half' / 'upper half' / 'bottom half' / 'lower half' → split on XY plane at Z midpoint"
    - "'left half' / 'right half' → split on XZ plane at Y midpoint (or YZ at X midpoint depending on convention)"
    - "'front half' / 'back half' → split on YZ plane at X midpoint"
    - "PREFERRED METHOD — use boolean intersection with a box:"
    - "  Lower half: sphere.intersect(cq.Workplane('XY').box(R*3, R*3, R).translate((0,0,-R/2)))"
    - "  Upper half: sphere.intersect(cq.Workplane('XY').box(R*3, R*3, R).translate((0,0,R/2)))"
    - "ALTERNATIVE — use .split() (less reliable): .workplane(offset=0).split(keepBottom=True)"
    - "COMMON MISTAKE: Do NOT split along X or Y when the user says 'top/bottom' — that produces a vertical D-shape, not a horizontal hemisphere"
    - "For a sphere centered at origin, 'lower half' = everything with Z < 0, 'upper half' = everything with Z > 0"

  face_selectors:
    - "'>Z' = topmost face (highest Z value, spindle side)"
    - "'<Z' = bottommost face (lowest Z value, table side)"
    - "'>X' = rightmost face"
    - "'<X' = leftmost face"
    - "'>Y' = front face (operator side)"
    - "'<Y' = back face"

# =============================================================================
# CADQUERY CODE REQUIREMENTS
# =============================================================================
code_requirements:
  mandatory:
    - "Always import cadquery as cq"
    - "Final result MUST be assigned to variable named 'result'"
    - "Use CadQuery's fluent API (method chaining)"
    - "All dimensions in millimeters"

  forbidden:
    - "Do NOT use show_object() or display()"
    - "Do NOT use cq.exporters directly - the runner handles export"
    - "Do NOT use matplotlib or any GUI libraries"
    - "Do NOT read/write files"

# =============================================================================
# CNC MANUFACTURING CONSTRAINTS
# =============================================================================
manufacturing:
  process: "CNC Milling (3-axis)"

  internal_radii:
    minimum: 1.5           # mm - typical smallest end mill radius
    recommended: 3.0       # mm - standard 6mm end mill
    rule: "All internal corners must have a radius >= 1.5mm (tool radius)"
    on_violation: "Add fillet to internal corners matching tool radius"
    note: "Internal corner radius = end mill radius. Specify which tool size."

  tool_access:
    rule: "All features must be accessible from the Z+ direction (3-axis)"
    max_reach_depth: 50    # mm - typical tool length
    undercuts_allowed: false
    rule_detail: "No undercuts, enclosed cavities, or features requiring tool approach from sides"
    on_violation: "Redesign feature to be accessible from top, or suggest multi-setup machining"

  pockets:
    min_corner_radius: 1.5      # mm - end mill radius
    max_depth_to_width_ratio: 3  # depth / pocket width
    min_width: 3.0              # mm - minimum pocket width (tool diameter)
    rule: "Pocket depth should not exceed 3x the pocket width"
    on_violation: "Suggest shallower pocket or wider opening"
    floor_flatness: "Pocket floors should be flat (no complex bottom surfaces)"

  holes:
    min_diameter: 1.0       # mm - smallest practical drill
    standard_sizes:         # prefer standard drill sizes
      - 2.0
      - 2.5
      - 3.0
      - 3.3
      - 4.0
      - 4.2
      - 5.0
      - 6.0
      - 6.8
      - 8.0
      - 10.0
    depth_to_diameter_ratio: 5  # max depth / diameter for drilling
    rule: "Prefer standard drill sizes. Depth should not exceed 5x diameter."

  walls:
    min_thickness: 1.0      # mm - thin walls deflect under cutting forces
    recommended: 2.0        # mm
    min_height_to_thickness_ratio: 8  # tall thin walls vibrate
    rule: "Walls must be >= 1.0mm thick. Height/thickness ratio <= 8."
    on_violation: "Increase wall thickness or reduce height"

  draft_angles:
    vertical_walls: 0       # degrees - CNC can cut vertical walls
    note: "Draft angles not required for CNC (unlike injection molding)"

  surface_finish:
    achievable_ra: 1.6      # micrometers Ra typical
    step_over_scallop: true
    rule: "Surface finish depends on step-over and tool radius"

  tolerances:
    general: 0.05           # mm - typical CNC tolerance
    tight: 0.01             # mm - achievable with care
    hole_position: 0.05     # mm
    rule: "Design with +/-0.05mm general tolerance. Tighter tolerances cost more."

  fixturing:
    flat_bottom_preferred: true
    min_clamping_surface: 100  # mm^2
    rule: "Ensure adequate flat surface for workholding"
    on_violation: "Add clamping tabs or redesign base for fixturing"

# =============================================================================
# VALIDATION CHECKS
# =============================================================================
validation:
  pre_generation:
    - check: "dimensions_realistic"
      rule: "All dimensions between 0.1mm and 2000mm (typical CNC range)"
      on_fail: "Warn about machine travel limits"

    - check: "internal_radii"
      rule: "All internal corners have radius >= 1.5mm"
      on_fail: "Add fillets to internal corners"

    - check: "tool_access"
      rule: "All features accessible from Z+ direction"
      on_fail: "Redesign for 3-axis accessibility"

    - check: "pocket_depth"
      rule: "No pockets deeper than 3x their width"
      on_fail: "Suggest shallower pocket or multi-step machining"

    - check: "wall_thickness"
      rule: "All walls >= 1.0mm thick"
      on_fail: "Increase wall thickness"

    - check: "cut_intersects"
      rule: "All cut operations must intersect target body"
      on_fail: "Recalculate cut position"

  post_generation:
    - check: "mesh_watertight"
      rule: "Generated mesh must be manifold"
      on_fail: "Report error, suggest fixes"

    - check: "no_self_intersection"
      rule: "No self-intersecting geometry"
      on_fail: "Simplify operations, rebuild step by step"

# =============================================================================
# ERROR HANDLING
# =============================================================================
on_error:
  spatial_confusion:
    - "STOP - do not guess"
    - "Draw ASCII diagram showing X, Y, Z axes with tool direction"
    - "List current body bounds: min/max for each axis"
    - "Calculate exact coordinates for intended operation"
    - "Verify calculation before generating code"

  cadquery_error:
    - "Read the Python traceback carefully"
    - "Identify which CadQuery operation failed"
    - "Check face/edge selectors are valid"
    - "Verify the workplane is correct"
    - "Fix and regenerate the complete code"

  general:
    - "Explain what went wrong in plain language"
    - "Show the problematic code section"
    - "Propose specific fix with reasoning"
    - "Ask user to confirm before applying"

# =============================================================================
# CODE GENERATION STYLE
# =============================================================================
code_style:
  naming:
    - "Use descriptive variable names: 'bolt_pocket_depth' not 'd1'"
    - "Use UPPER_CASE for dimension constants"
    - "Use lowercase for intermediate results"

  comments:
    - "Comment the INTENT, not the operation"
    - "Note tool size requirements for internal features"
    - "Indicate machining setup/orientation"

  organization:
    - "Define dimensions as named constants at top"
    - "Group related operations"
    - "Use intermediate variables for complex geometry"
    - "Include tool radius as a named constant"

  example: |
    import cadquery as cq

    # Mounting plate - designed for 3-axis CNC milling
    # Material: 6061 Aluminum
    # Setup: clamp bottom, machine from top (Z+)
    # Tool: 6mm end mill (R3.0 internal corners)

    TOOL_RADIUS = 3.0       # mm - 6mm end mill
    PLATE_W = 80.0          # mm - plate width
    PLATE_D = 60.0          # mm - plate depth
    PLATE_H = 10.0          # mm - plate thickness
    POCKET_DEPTH = 5.0      # mm - pocket depth (ratio 0.5:1)
    BOLT_HOLE_DIA = 5.5     # mm - clearance for M5

    result = (
        cq.Workplane("XY")
        .box(PLATE_W, PLATE_D, PLATE_H)
        # Central pocket with tool-radius corners
        .faces(">Z")
        .workplane()
        .rect(40, 30)
        .cutBlind(-POCKET_DEPTH)
        # Fillet internal corners to match end mill
        .edges("|Z")
        .fillet(TOOL_RADIUS)
        # Mounting holes in corners
        .faces(">Z")
        .workplane()
        .pushPoints([(30, 20), (-30, 20), (30, -20), (-30, -20)])
        .hole(BOLT_HOLE_DIA)
    )

# =============================================================================
# CAPABILITIES & LIMITATIONS
# =============================================================================
capabilities:
  excels_at:
    - "Parametric mechanical parts (brackets, enclosures, gears, flanges)"
    - "Precise geometry with exact dimensions and tight tolerances"
    - "Profile-based modeling: sketch 2D shape, then extrude/revolve/sweep/loft"
    - "Boolean operations to build complex shapes from simple primitives"
    - "Patterned features: arrays, mirrors, circular patterns"
    - "Shelling, filleting, chamfering with precise control"
    - "CNC-ready models with tool-radius internal corners and accessible features"
  limitations:
    - "CANNOT create true organic/sculpted surfaces (faces, characters, animals)"
    - "CANNOT do freeform NURBS surface modeling"
    - "Splines are approximate - good for gentle curves, not complex organic shapes"
    - "Very complex boolean operations (>10 bodies) may fail or be slow"
  strategy_for_complex_requests:
    - "ALWAYS break complex shapes into simpler sub-parts"
    - "Use boolean union/cut/intersect to combine sub-parts"
    - "Approximate organic curves with: revolve + polyline profiles, loft between shapes, generous fillets"
    - "For helmet/mask/vehicle shapes: start with spheres/ellipsoids, cut and combine"
    - "If a shape cannot be built, explain the limitation and offer the closest approximation"
    - "Prefer simpler geometry that WORKS over complex geometry that FAILS"
    - "Ensure all features are accessible from the tool direction (Z+ for 3-axis)"

# =============================================================================
# ADVANCED TECHNIQUES
# =============================================================================
advanced_techniques:
  profile_based_modeling:
    - "Most complex shapes start as a 2D sketch swept into 3D"
    - "revolve(): Axially symmetric shapes (vases, bowls, domes, wheels)"
    - "sweep(): Profile follows a path (pipes, channels, rails)"
    - "loft(): Smooth blend between different cross-sections"
  approximating_organic_shapes:
    - "Hemispheres: sphere + intersect with half-space box"
    - "Rounded bodies: loft between roundedRect profiles at different heights"
    - "Smooth transitions: large-radius fillets after boolean unions"
    - "Teardrop/egg shapes: revolve a spline profile"
    - "Complex enclosures: loft + shell"
    - "Helmet-like shapes: hemisphere + cylinder extensions + boolean cuts for openings"
  cnc_specific_techniques:
    - "Always add tool-radius fillets to internal corners (min 1.5mm for 3mm end mill)"
    - "Design pockets with depth/width ratio <= 3:1"
    - "Ensure all features accessible from spindle direction"
    - "Use standard drill sizes for holes when possible"
  common_pitfalls:
    - "Fillet radius larger than edge length causes crash - use smaller radius"
    - "Shell on body with thin features causes crash - simplify first"
    - "Boolean operations on non-overlapping bodies do nothing (no error, no effect)"
    - "Revolve profile must be entirely on one side of the axis"
    - "Sweep path must be a Wire object (.wire()), not just edges"
    - "Loft profiles should have same number of segments for clean results"
    - "Apply fillets/chamfers LAST, after all boolean operations"
    - "Internal corners must have fillet radius >= tool radius"

# =============================================================================
# DESIGN THINKING (mandatory pre-generation reasoning)
# =============================================================================
design_thinking:
  mandatory_before_code:
    - "Before writing ANY code, describe the object's geometry in plain English"
    - "List each geometric feature and what CadQuery operation implements it"
    - "Specify approximate dimensions and positions for each feature"
    - "Plan the build sequence (what order to apply operations)"
    - "Identify the base shape that everything else builds upon"

  for_organic_shapes:
    - "Describe the cross-section profile at multiple heights (bottom, middle, top)"
    - "Use revolve() with spline/polyline profiles for axially symmetric parts"
    - "Use loft() between profiles at different heights for varying shapes"
    - "Apply generous fillets (3-8mm) to smooth sharp boolean transitions"
    - "Accept approximation — describe what the closest buildable shape is"
    - "For helmet/mask shapes: use loft between oval profiles, NOT just a sphere with cuts"

  for_complex_objects:
    - "Decompose into major sub-assemblies first (e.g. body, lid, handle)"
    - "For each sub-assembly, identify the base shape and modifications"
    - "Plan boolean operations: which parts get unioned, which get cut"
    - "Verify each cut tool overlaps the target before writing code"
    - "Think about what makes the object RECOGNIZABLE and prioritize those features"

# =============================================================================
# RESPONSE FORMAT
# =============================================================================
response_format:
  on_success:
    - "Brief description of what was created"
    - "The generated CadQuery code wrapped in <CODE>...</CODE> tags"
    - "Recommended material and tool sizes"
    - "Machining setup notes (fixturing, orientation)"
    - "Any features requiring special attention"

  on_clarification_needed:
    - "Explain what information is missing"
    - "Provide 2-3 specific options to choose from"
    - "Default suggestion optimized for CNC machining"

  never:
    - "Never generate code for ambiguous requests without asking"
    - "Never assume dimensions - always ask if not specified"
    - "Never skip machinability validation"
    - "Never create internal corners without tool-radius fillets"
    - "Never create undercut features without warning about 3-axis limitations"

# =============================================================================
# CADQUERY COOKBOOK - REFERENCE PATTERNS
# =============================================================================
# Use these as reference for correct CadQuery API usage.
# Each recipe is a self-contained working example.

cookbook:
  - title: "Hollow box (shell operation)"
    description: "Create a box and shell it to make a container with uniform wall thickness"
    code: |
      import cadquery as cq
      W, D, H = 60.0, 40.0, 30.0
      WALL = 2.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .shell(-WALL)
      )

  - title: "Through-cut slot on a wall face"
    description: "Select a specific face and cut a slot that goes all the way through"
    code: |
      import cadquery as cq
      W, D, H = 60.0, 40.0, 30.0
      SLOT_W, SLOT_H = 20.0, 10.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          # Select the front face (+X), place workplane, cut through
          .faces(">X")
          .workplane()
          .rect(SLOT_W, SLOT_H)
          .cutThruAll()
      )

  - title: "Opposing through-slots on two walls"
    description: "Cut matching slots on opposite faces - e.g. entry ports on both short sides of a box"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 40.0, 30.0
      WALL = 2.0
      SLOT_W, SLOT_H = 20.0, 12.0
      # Start with a hollow box
      box = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .shell(-WALL)
      )
      # Cut slot on front face (+X)
      box = (
          box.faces(">X")
          .workplane()
          .rect(SLOT_W, SLOT_H)
          .cutThruAll()
      )
      # Cut slot on back face (-X)
      result = (
          box.faces("<X")
          .workplane()
          .rect(SLOT_W, SLOT_H)
          .cutThruAll()
      )

  - title: "Fillets and chamfers on specific edges"
    description: "Apply fillets or chamfers to selected edges using edge selectors"
    code: |
      import cadquery as cq
      W, D, H = 50.0, 30.0, 20.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          # Fillet only the top edges
          .edges(">Z")
          .fillet(2.0)
          # Chamfer only the bottom edges
          .edges("<Z")
          .chamfer(1.0)
      )

  - title: "Pattern of holes (pushPoints)"
    description: "Create multiple holes at specific positions using pushPoints"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 60.0, 5.0
      HOLE_DIA = 5.5
      # Hole positions as (x, y) tuples on the top face
      HOLE_POS = [(30, 20), (-30, 20), (30, -20), (-30, -20)]
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .workplane()
          .pushPoints(HOLE_POS)
          .hole(HOLE_DIA)
      )

  - title: "Boolean operations (cut, union, intersect)"
    description: "Combine two bodies using boolean cut, union, or intersect"
    code: |
      import cadquery as cq
      # Base plate
      plate = cq.Workplane("XY").box(60, 40, 5)
      # Cylinder to add on top
      boss = cq.Workplane("XY").workplane(offset=5).circle(10).extrude(15)
      # Hole to subtract
      hole = cq.Workplane("XY").circle(4).extrude(20)
      # Union the boss onto the plate, then cut the hole
      result = plate.union(boss).cut(hole)

  - title: "Workplane switching and offsets"
    description: "Work on different planes and at offsets from existing geometry"
    code: |
      import cadquery as cq
      BASE_H = 10.0
      # Base on XY plane
      base = cq.Workplane("XY").box(40, 40, BASE_H)
      # Switch to top face and extrude a smaller block upward
      result = (
          base.faces(">Z")
          .workplane()
          .rect(20, 20)
          .extrude(15)
      )

  - title: "Concentric circles for tubes and rings"
    description: "Create a tube or ring using concentric circles"
    code: |
      import cadquery as cq
      OUTER_R = 20.0
      INNER_R = 16.0
      HEIGHT = 30.0
      result = (
          cq.Workplane("XY")
          .circle(OUTER_R)
          .circle(INNER_R)
          .extrude(HEIGHT)
      )

  - title: "Revolve (wine glass)"
    description: "Create axially symmetric shapes by revolving a polyline profile around an axis"
    code: |
      import cadquery as cq
      # Wine glass profile (half cross-section) - points from bottom to top
      # Profile must be entirely on one side of the revolve axis (positive X here)
      profile_pts = [
          (0, 0),      # center bottom of base
          (30, 0),     # outer edge of base
          (30, 3),     # base thickness
          (3, 3),      # start of stem
          (3, 60),     # top of stem
          (25, 80),    # bowl flare
          (25, 100),   # bowl top outer
          (23, 100),   # bowl top inner (wall thickness)
          (23, 82),    # bowl inner
          (0, 65),     # bowl bottom center
      ]
      result = (
          cq.Workplane("XZ")
          .polyline(profile_pts)
          .close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )

  - title: "Sweep (pipe along path)"
    description: "Sweep a circular profile along a wire path to create a pipe or channel"
    code: |
      import cadquery as cq
      PIPE_RADIUS = 5.0
      # Create a path using a series of points with arcs
      path = (
          cq.Workplane("XZ")
          .moveTo(0, 0)
          .lineTo(0, 30)
          .threePointArc((15, 45), (30, 45))
          .lineTo(60, 45)
          .wire()
      )
      # Sweep a circle along the path
      result = (
          cq.Workplane("XY")
          .circle(PIPE_RADIUS)
          .sweep(path)
      )

  - title: "Loft (square to circle transition)"
    description: "Smooth blend between different cross-section shapes at different heights"
    code: |
      import cadquery as cq
      # Bottom profile: 40x40 rounded rectangle
      bottom = cq.Workplane("XY").rect(40, 40)
      # Top profile: circle at Z=50
      top = cq.Workplane("XY").workplane(offset=50).circle(15)
      # Loft between the two profiles
      result = bottom.loft(top)

  - title: "Spline curves (ergonomic shape)"
    description: "Use splines for smooth organic-ish curves, then revolve for 3D shape"
    code: |
      import cadquery as cq
      # Spline profile for an egg/teardrop shape (revolve around Y axis)
      spline_pts = [
          (0, 0),
          (12, 10),
          (18, 25),
          (15, 45),
          (8, 55),
          (0, 60),
      ]
      result = (
          cq.Workplane("XZ")
          .spline(spline_pts)
          .close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )

  - title: "Advanced edge selectors"
    description: "Select edges by direction, position, and compound filters"
    code: |
      import cadquery as cq
      W, D, H = 60.0, 40.0, 30.0
      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          # '|Z' selects edges parallel to Z axis (vertical edges)
          .edges("|Z")
          .fillet(3.0)
          # '>Z' selects edges at the maximum Z (top edges)
          .edges(">Z")
          .chamfer(1.0)
      )

  - title: "Shell with face removal and ports"
    description: "Create a hollow enclosure by shelling then cutting access ports"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 50.0, 40.0
      WALL = 2.5
      PORT_DIA = 15.0
      # Shell removes material from inside, opening the selected face
      enclosure = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .shell(-WALL)
      )
      # Cut a circular port on the front face
      result = (
          enclosure.faces(">X")
          .workplane()
          .hole(PORT_DIA)
      )

  - title: "Complex boolean composition (helmet shape)"
    description: "Build complex shapes from simple primitives using boolean operations"
    code: |
      import cadquery as cq
      R = 50.0       # head radius
      WALL = 3.0     # shell thickness
      VISOR_W = 60.0
      VISOR_H = 25.0

      # Start with a sphere
      sphere = cq.Workplane("XY").sphere(R)
      # Cut bottom half to get hemisphere (dome)
      cut_box = cq.Workplane("XY").box(R * 3, R * 3, R).translate((0, 0, -R / 2))
      dome = sphere.cut(cut_box)
      # Extend downward with a cylinder for the jaw area
      jaw = cq.Workplane("XY").circle(R).extrude(-20)
      helmet_solid = dome.union(jaw)
      # Shell it to make it hollow
      helmet = helmet_solid.shell(-WALL)
      # Cut visor opening on front face
      visor_cut = (
          cq.Workplane("XZ")
          .workplane(offset=R)
          .rect(VISOR_W, VISOR_H)
          .extrude(-WALL * 3)
      )
      result = helmet.cut(visor_cut)

  - title: "Circular pattern (polar array of holes)"
    description: "Create features arranged in a circular pattern using polarArray"
    code: |
      import cadquery as cq
      DISC_R = 40.0
      DISC_H = 8.0
      HOLE_DIA = 6.0
      HOLE_CIRCLE_R = 30.0
      NUM_HOLES = 6

      result = (
          cq.Workplane("XY")
          .circle(DISC_R)
          .extrude(DISC_H)
          .faces(">Z")
          .workplane()
          .polarArray(HOLE_CIRCLE_R, 0, 360, NUM_HOLES)
          .hole(HOLE_DIA)
      )

  - title: "Text embossing on a face"
    description: "Add raised or engraved text to a face of a solid"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 30.0, 5.0
      FONT_SIZE = 10.0
      TEXT_DEPTH = 1.0   # positive = raised, negative would need .cutBlind

      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .workplane()
          .text("HELLO", FONT_SIZE, TEXT_DEPTH)
      )

  - title: "Rounded enclosure (loft between rounded rectangles)"
    description: "Create a smooth enclosure by lofting between rounded rectangles at different heights"
    code: |
      import cadquery as cq
      W_BOT, D_BOT = 60.0, 40.0  # bottom dimensions
      W_TOP, D_TOP = 50.0, 35.0  # top dimensions (slightly smaller)
      HEIGHT = 30.0
      CORNER_R = 5.0
      WALL = 2.0

      # Bottom profile
      bottom = cq.Workplane("XY").rect(W_BOT, D_BOT).val()
      # Top profile
      top = cq.Workplane("XY").workplane(offset=HEIGHT).rect(W_TOP, D_TOP).val()
      # Loft and shell
      result = (
          cq.Workplane("XY")
          .rect(W_BOT, D_BOT)
          .workplane(offset=HEIGHT)
          .rect(W_TOP, D_TOP)
          .loft()
          .edges("|Z")
          .fillet(CORNER_R)
          .faces(">Z")
          .shell(-WALL)
      )

  - title: "Countersink and counterbore holes"
    description: "Create standard countersink (cskHole) and counterbore (cboreHole) holes for fasteners"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 40.0, 10.0

      result = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .workplane()
          # Counterbore hole: hole_dia, cbore_dia, cbore_depth
          .pushPoints([(-20, 0)])
          .cboreHole(5.0, 10.0, 3.0)
          # Countersink hole: hole_dia, csk_dia, csk_angle (82 or 90 deg typical)
          .pushPoints([(20, 0)])
          .cskHole(5.0, 10.0, 82)
      )

  - title: "Multi-body workflow (separate parts combined)"
    description: "Build complex models from separate bodies using translate and boolean union"
    code: |
      import cadquery as cq
      # Body 1: base plate
      base = cq.Workplane("XY").box(80, 60, 5)
      # Body 2: left pillar
      pillar_l = (
          cq.Workplane("XY")
          .workplane(offset=5)
          .center(-30, 0)
          .circle(8)
          .extrude(40)
      )
      # Body 3: right pillar
      pillar_r = (
          cq.Workplane("XY")
          .workplane(offset=5)
          .center(30, 0)
          .circle(8)
          .extrude(40)
      )
      # Body 4: top bridge
      bridge = cq.Workplane("XY").workplane(offset=45).box(76, 16, 5)
      # Combine all parts, then fillet the joints
      combined = base.union(pillar_l).union(pillar_r).union(bridge)
      # Apply fillets LAST after all booleans
      result = combined.edges("|Z").fillet(2.0)

  - title: "Helmet shape via multi-height loft + boolean cuts"
    description: "Build a helmet-like shape by lofting between oval profiles at different heights, then cutting visor and mouth openings. Much better than sphere + cuts."
    code: |
      import cadquery as cq

      H_WIDTH = 180.0
      H_DEPTH = 220.0
      H_HEIGHT = 200.0
      WALL = 4.0

      helmet = (
          cq.Workplane("XY")
          .ellipse(H_WIDTH / 2, H_DEPTH / 2)
          .workplane(offset=H_HEIGHT * 0.4)
          .ellipse(H_WIDTH / 2 * 1.05, H_DEPTH / 2 * 1.05)
          .workplane(offset=H_HEIGHT * 0.35)
          .ellipse(H_WIDTH / 2 * 0.85, H_DEPTH / 2 * 0.9)
          .workplane(offset=H_HEIGHT * 0.25)
          .ellipse(H_WIDTH / 2 * 0.4, H_DEPTH / 2 * 0.5)
          .loft()
      )
      helmet = helmet.faces("<Z").shell(-WALL)

      VISOR_W = 140.0
      VISOR_H = 40.0
      VISOR_Z = H_HEIGHT * 0.55
      visor_cutter = (
          cq.Workplane("XZ")
          .center(0, VISOR_Z)
          .rect(VISOR_W, VISOR_H)
          .extrude(H_DEPTH)
      )
      helmet = helmet.cut(visor_cutter)

      MOUTH_W = 60.0
      MOUTH_H = 15.0
      MOUTH_Z = H_HEIGHT * 0.3
      mouth_cutter = (
          cq.Workplane("XZ")
          .center(0, MOUTH_Z)
          .rect(MOUTH_W, MOUTH_H)
          .extrude(H_DEPTH)
      )
      helmet = helmet.cut(mouth_cutter)
      result = helmet.edges().fillet(2.0)

  - title: "Ergonomic handle via revolve with spline profile"
    description: "Create a grip/handle shape using revolve with a spline profile curve."
    code: |
      import cadquery as cq

      PROFILE_PTS = [
          (0, 0), (12, 0), (14, 10), (16, 30), (15, 50),
          (12, 70), (8, 90), (10, 100), (10, 105), (0, 105),
      ]

      handle_profile = (
          cq.Workplane("XZ")
          .moveTo(*PROFILE_PTS[0])
      )
      handle_profile = handle_profile.spline(PROFILE_PTS[1:], includeCurrent=True)
      handle_profile = handle_profile.close()
      result = handle_profile.revolve(360, (0, 0, 0), (0, 0, 1))

  - title: "Phone case using loft + shell + boolean cuts for ports"
    description: "Build a phone case shape by lofting rounded rectangles, shelling, then cutting openings."
    code: |
      import cadquery as cq

      PH_W = 75.0
      PH_D = 155.0
      PH_T = 10.0
      WALL = 1.5
      CORNER_R = 8.0

      case_body = (
          cq.Workplane("XY")
          .rect(PH_W, PH_D)
          .workplane(offset=PH_T)
          .rect(PH_W + 1.0, PH_D + 1.0)
          .loft()
          .edges("|Z")
          .fillet(CORNER_R)
      )
      case_body = case_body.faces(">Z").shell(-WALL)

      CAM_X = -PH_W / 2 + 20.0
      CAM_Y = PH_D / 2 - 25.0
      cam_cutter = (
          cq.Workplane("XY")
          .center(CAM_X, CAM_Y)
          .rect(30.0, 35.0)
          .extrude(-WALL * 2)
      )
      case_body = case_body.cut(cam_cutter)

      port_cutter = (
          cq.Workplane("XZ")
          .workplane(offset=-PH_D / 2)
          .rect(15.0, 5.0)
          .extrude(-WALL * 2)
      )
      result = case_body.cut(port_cutter)

  # --- Phase 1.1: Expanded Recipes (25 new) ---

  # A. Plumbing & Fluid

  - title: "Pipe elbow (90-degree swept bend)"
    description: "Sweep a circular profile along a 90-degree arc to create a pipe elbow"
    code: |
      import cadquery as cq
      PIPE_OD = 20.0
      PIPE_WALL = 2.0
      BEND_R = 40.0  # center-line bend radius
      # 90-degree arc path in XZ plane
      path = (
          cq.Workplane("XZ")
          .radiusArc((BEND_R, BEND_R), -BEND_R)
          .wire()
      )
      # Sweep annular profile (outer - inner circle)
      result = (
          cq.Workplane("XY")
          .circle(PIPE_OD / 2)
          .circle(PIPE_OD / 2 - PIPE_WALL)
          .sweep(path)
      )

  - title: "Pipe T-junction"
    description: "Create a hollow T-junction from outer and inner cylinder booleans (shell on complex unions is unreliable)"
    code: |
      import cadquery as cq
      OD = 20.0
      WALL = 2.0
      ID = OD - 2 * WALL
      LENGTH = 60.0
      BRANCH_L = 40.0
      # Outer solid T-shape
      main_outer = cq.Workplane("XY").circle(OD / 2).extrude(LENGTH).translate((0, 0, -LENGTH / 2))
      branch_outer = cq.Workplane("XZ").circle(OD / 2).extrude(BRANCH_L)
      outer = main_outer.union(branch_outer)
      # Inner void T-shape (slightly longer to ensure clean cut)
      main_inner = cq.Workplane("XY").circle(ID / 2).extrude(LENGTH + 2).translate((0, 0, -LENGTH / 2 - 1))
      branch_inner = cq.Workplane("XZ").circle(ID / 2).extrude(BRANCH_L + 1)
      inner = main_inner.union(branch_inner)
      result = outer.cut(inner)

  # B. Fasteners & Hardware

  - title: "Hex bolt (simplified, no threads)"
    description: "Hex head polygon extruded + cylindrical shaft with chamfered tip. No real threads — helix sweep is unreliable in CadQuery."
    code: |
      import cadquery as cq
      # M8 approximate dimensions
      HEAD_AF = 13.0   # across-flats (wrench size)
      HEAD_H = 5.3
      SHAFT_D = 8.0
      SHAFT_L = 30.0
      # Hex head: inscribed polygon (6 sides)
      head = (
          cq.Workplane("XY")
          .polygon(6, HEAD_AF)
          .extrude(HEAD_H)
      )
      # Shaft below head
      shaft = (
          cq.Workplane("XY")
          .circle(SHAFT_D / 2)
          .extrude(-SHAFT_L)
      )
      result = (
          head.union(shaft)
          .edges("<Z")
          .chamfer(0.8)
      )

  - title: "Compression spring (helix sweep)"
    description: "Sweep a small circle along a helix path to create a compression spring"
    code: |
      import cadquery as cq
      WIRE_DIA = 2.0
      COIL_OD = 20.0
      PITCH = 6.0
      N_COILS = 5
      HEIGHT = PITCH * N_COILS
      COIL_R = (COIL_OD - WIRE_DIA) / 2
      # Create helix path
      helix = cq.Wire.makeHelix(PITCH, HEIGHT, COIL_R)
      # Sweep wire cross-section along helix
      result = (
          cq.Workplane("XZ")
          .center(COIL_R, 0)
          .circle(WIRE_DIA / 2)
          .sweep(helix, isFrenet=True)
      )

  - title: "Standoff / spacer with hex base"
    description: "Hex base polygon + hollow cylindrical body + through-hole for a screw"
    code: |
      import cadquery as cq
      HEX_AF = 8.0     # across-flats
      HEX_H = 3.0
      BODY_OD = 6.0
      BODY_H = 10.0
      BORE_D = 3.2     # M3 clearance
      # Hex base
      base = cq.Workplane("XY").polygon(6, HEX_AF).extrude(HEX_H)
      # Round body on top
      body = cq.Workplane("XY").workplane(offset=HEX_H).circle(BODY_OD / 2).extrude(BODY_H)
      # Union, then drill through-hole
      result = (
          base.union(body)
          .faces(">Z").workplane()
          .hole(BORE_D)
      )

  - title: "Bearing seat (revolved stepped bore)"
    description: "Revolve a stepped bore profile with shoulder and snap-ring groove for a bearing housing"
    code: |
      import cadquery as cq
      # Profile (half cross-section) for revolve around Z axis
      # OD=40, bearing bore=22, shoulder, snap-ring groove
      pts = [
          (0, 0), (20, 0), (20, 5),           # bottom flange
          (16, 5), (16, 8),                     # step to bore
          (11, 8), (11, 25),                    # bearing bore wall
          (12, 25), (12, 27), (11, 27),         # snap-ring groove
          (11, 30), (20, 30), (20, 35),         # top flange
          (0, 35),                              # top center
      ]
      result = (
          cq.Workplane("XZ")
          .polyline(pts)
          .close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )

  # C. Joints & Connections

  - title: "Snap-fit hook (cantilever with barb)"
    description: "A cantilever arm with an angled barb tip, extruded from a polyline profile"
    code: |
      import cadquery as cq
      ARM_L = 15.0
      ARM_T = 1.5
      ARM_W = 5.0
      BARB_H = 2.0
      BARB_ANGLE_RUN = 1.5  # horizontal run of barb slope
      BASE_H = 5.0
      # Side profile of snap-fit hook (XZ plane)
      pts = [
          (0, 0), (ARM_T, 0), (ARM_T, BASE_H),         # base block
          (ARM_T, BASE_H + ARM_L),                       # arm tip
          (ARM_T + BARB_ANGLE_RUN, BASE_H + ARM_L + BARB_H),  # barb peak
          (ARM_T, BASE_H + ARM_L + BARB_H),             # barb inner
          (0, BASE_H + ARM_L + BARB_H),                 # back of barb
          (0, BASE_H),                                   # back to base top
      ]
      result = (
          cq.Workplane("XZ")
          .polyline(pts)
          .close()
          .extrude(ARM_W)
      )

  - title: "Snap-fit clip (U-shaped with detent bumps)"
    description: "U-shaped clip body with small detent bumps on inner arms for push-fit retention"
    code: |
      import cadquery as cq
      W = 12.0      # overall width
      H = 15.0      # arm height
      T = 1.5       # wall thickness
      GAP = 6.0     # inner gap
      DEPTH = 8.0   # extrusion depth
      BUMP_R = 0.8
      # U-shape profile
      pts = [
          (0, 0), (W, 0), (W, H),
          (W - T, H), (W - T, T), (T, T),
          (T, H), (0, H),
      ]
      clip = (
          cq.Workplane("XZ")
          .polyline(pts)
          .close()
          .extrude(DEPTH)
      )
      # Add detent bumps on inner faces of arms
      bump_l = cq.Workplane("XY").workplane(offset=H * 0.7).center(T, DEPTH / 2).sphere(BUMP_R)
      bump_r = cq.Workplane("XY").workplane(offset=H * 0.7).center(W - T, DEPTH / 2).sphere(BUMP_R)
      result = clip.union(bump_l).union(bump_r)

  - title: "Dovetail joint (male and female pieces)"
    description: "Trapezoidal male dovetail piece and matching female block with trapezoidal cutout"
    code: |
      import cadquery as cq
      # Dovetail cross-section (trapezoid)
      BASE_W = 10.0
      TOP_W = 14.0
      DT_H = 8.0
      LENGTH = 40.0
      BLOCK = 30.0
      # Male dovetail piece
      tail_pts = [
          (-BASE_W / 2, 0), (BASE_W / 2, 0),
          (TOP_W / 2, DT_H), (-TOP_W / 2, DT_H),
      ]
      male = (
          cq.Workplane("XZ")
          .polyline(tail_pts).close()
          .extrude(LENGTH)
      )
      # Female piece: block with dovetail slot cut through
      block = cq.Workplane("XY").box(BLOCK, LENGTH, BLOCK)
      slot_cutter = (
          cq.Workplane("XZ")
          .polyline(tail_pts).close()
          .extrude(LENGTH * 1.1)
          .translate((0, -LENGTH * 0.05, 0))
      )
      female = block.cut(slot_cutter)
      # Return male piece (change to female if needed)
      result = male

  - title: "Finger joint (box joint)"
    description: "Two interlocking boards with rectangular finger tabs cut in a loop"
    code: |
      import cadquery as cq
      BOARD_W = 60.0
      BOARD_H = 40.0
      BOARD_T = 5.0
      N_FINGERS = 5
      FINGER_W = BOARD_W / (N_FINGERS * 2 + 1)
      # Board A: fingers at even positions
      board_a = cq.Workplane("XY").box(BOARD_W, BOARD_T, BOARD_H)
      for i in range(N_FINGERS):
          x_pos = -BOARD_W / 2 + FINGER_W * (2 * i + 1) + FINGER_W / 2
          cutter = (
              cq.Workplane("XY")
              .center(x_pos, 0)
              .rect(FINGER_W, BOARD_T * 2)
              .extrude(BOARD_T)
              .translate((0, 0, -BOARD_T / 2))
          )
          board_a = board_a.cut(cutter)
      result = board_a

  # D. Brackets & Structural

  - title: "L-bracket with gusset and mounting holes"
    description: "L-profile from polyline extrude, triangular gusset for stiffness, and mounting holes"
    code: |
      import cadquery as cq
      W = 40.0      # width (extrusion)
      LEG = 50.0    # leg lengths
      T = 4.0       # thickness
      HOLE_D = 5.5  # M5 clearance
      # L-profile
      l_pts = [
          (0, 0), (LEG, 0), (LEG, T),
          (T, T), (T, LEG), (0, LEG),
      ]
      bracket = cq.Workplane("XZ").polyline(l_pts).close().extrude(W)
      # Triangular gusset
      gusset_pts = [(T, T), (T + 15, T), (T, T + 15)]
      gusset = (
          cq.Workplane("XZ").polyline(gusset_pts).close()
          .extrude(W * 0.3).translate((0, W * 0.35, 0))
      )
      bracket = bracket.union(gusset)
      # Mounting holes on horizontal leg
      bracket = (
          bracket.faces("<Z").workplane()
          .pushPoints([(20, W / 2 - 10), (40, W / 2 - 10)])
          .hole(HOLE_D)
      )
      result = bracket

  - title: "Shelf bracket (triangular plate with fillet)"
    description: "Triangular bracket plate from polyline profile with fillet and two mounting holes"
    code: |
      import cadquery as cq
      ARM_H = 80.0   # vertical arm
      ARM_W = 60.0   # horizontal arm
      T = 5.0         # thickness
      HOLE_D = 6.0
      FILLET_R = 15.0
      # Triangular profile
      pts = [(0, 0), (ARM_W, 0), (0, ARM_H)]
      bracket = (
          cq.Workplane("XZ")
          .polyline(pts).close()
          .extrude(T)
      )
      # Fillet the hypotenuse edge (longest edge at mid-height)
      bracket = bracket.edges("|Y").fillet(FILLET_R)
      # Mounting holes on the vertical leg
      result = (
          bracket.faces("<X").workplane()
          .pushPoints([(T / 2, 15), (T / 2, ARM_H - 15)])
          .hole(HOLE_D)
      )

  # E. Enclosures & Cases

  - title: "Electronics enclosure with standoffs"
    description: "Rectangular box with shell, corner standoff cylinders, and screw holes"
    code: |
      import cadquery as cq
      W, D, H = 80.0, 60.0, 30.0
      WALL = 2.0
      STANDOFF_D = 6.0
      STANDOFF_H = 5.0
      SCREW_D = 2.5   # M2.5
      # Shell the box
      enclosure = (
          cq.Workplane("XY")
          .box(W, D, H)
          .faces(">Z")
          .shell(-WALL)
      )
      # Corner standoff positions (inset from corners)
      INSET = 6.0
      corners = [
          (W / 2 - INSET, D / 2 - INSET),
          (-W / 2 + INSET, D / 2 - INSET),
          (W / 2 - INSET, -D / 2 + INSET),
          (-W / 2 + INSET, -D / 2 + INSET),
      ]
      # Add standoff cylinders on inside floor
      standoffs = cq.Workplane("XY").workplane(offset=WALL)
      for cx, cy in corners:
          post = cq.Workplane("XY").workplane(offset=WALL).center(cx, cy).circle(STANDOFF_D / 2).extrude(STANDOFF_H)
          enclosure = enclosure.union(post)
      # Drill screw holes through standoffs
      result = (
          enclosure.faces(">Z").workplane(offset=-H + WALL + STANDOFF_H)
          .pushPoints(corners)
          .hole(SCREW_D)
      )

  - title: "Raspberry Pi case (real dimensions)"
    description: "92x63x25mm case with shell, USB-C / HDMI / SD card cutouts, and standoffs at Pi mounting holes"
    code: |
      import cadquery as cq
      # Pi 5 approximate board + case dims
      W, D, H = 92.0, 63.0, 25.0
      WALL = 2.0
      # Standoff positions (Pi mounting holes, relative to center)
      MOUNTS = [(24.5, 24.5), (-24.5, 24.5), (24.5, -24.5), (-24.5, -24.5)]
      case = (
          cq.Workplane("XY").box(W, D, H)
          .edges("|Z").fillet(3.0)
          .faces(">Z").shell(-WALL)
      )
      # Add standoffs
      for mx, my in MOUNTS:
          post = cq.Workplane("XY").workplane(offset=WALL).center(mx, my).circle(3.0).extrude(4.0)
          case = case.union(post)
      # USB-C cutout on front face
      case = case.faces(">X").workplane().center(0, -3).rect(9.0, 3.5).cutBlind(-WALL * 2)
      # Micro-HDMI cutout
      case = case.faces(">X").workplane().center(-15, -3).rect(7.5, 3.5).cutBlind(-WALL * 2)
      # SD card slot on left side
      case = case.faces("<Y").workplane().center(10, -3).rect(14.0, 2.5).cutBlind(-WALL * 2)
      result = case

  - title: "Battery holder (AA size)"
    description: "Rectangular cavity sized for AA battery with end clips and terminal contact slots"
    code: |
      import cadquery as cq
      # AA battery: 14.5mm dia x 50.5mm length
      BAT_D = 14.5
      BAT_L = 50.5
      WALL = 2.0
      CLIP_T = 1.0
      CLIP_H = 8.0
      SLOT_W = 4.0
      # Outer box around battery
      OW = BAT_D + WALL * 2
      OD = BAT_L + WALL * 2 + 4.0  # extra for spring contact
      OH = BAT_D / 2 + WALL + 2.0
      holder = cq.Workplane("XY").box(OW, OD, OH)
      # Cavity for battery (cylindrical)
      cavity = (
          cq.Workplane("YZ")
          .center(0, WALL + BAT_D / 2)
          .circle(BAT_D / 2 + 0.3)  # clearance
          .extrude(BAT_L + 2.0)
          .translate((0, -BAT_L / 2 - 1.0, 0))
      )
      holder = holder.cut(cavity)
      # Terminal slots on both ends
      slot1 = cq.Workplane("XY").box(SLOT_W, WALL * 2, CLIP_H).translate((0, OD / 2, CLIP_H / 2))
      slot2 = cq.Workplane("XY").box(SLOT_W, WALL * 2, CLIP_H).translate((0, -OD / 2, CLIP_H / 2))
      result = holder.cut(slot1).cut(slot2)

  # F. Rotational Parts

  - title: "Spur gear (simplified involute)"
    description: "Simplified spur gear with 12 teeth using polyline tooth profile and polarArray, plus center bore"
    code: |
      import cadquery as cq
      import math
      N_TEETH = 12
      MODULE = 2.5
      FACE_W = 8.0
      BORE_D = 10.0
      PD = MODULE * N_TEETH       # pitch diameter
      OD = PD + 2 * MODULE        # outer diameter
      RD = PD - 2.5 * MODULE      # root diameter
      TOOTH_ARC = 360.0 / N_TEETH
      HALF_T = TOOTH_ARC / 4      # half tooth angular width in degrees
      # Build a single tooth profile (simplified trapezoidal)
      r_root = RD / 2
      r_pitch = PD / 2
      r_tip = OD / 2
      a = math.radians(HALF_T)
      tooth_pts = [
          (r_root * math.cos(-a * 1.2), r_root * math.sin(-a * 1.2)),
          (r_tip * math.cos(-a * 0.4), r_tip * math.sin(-a * 0.4)),
          (r_tip * math.cos(a * 0.4), r_tip * math.sin(a * 0.4)),
          (r_root * math.cos(a * 1.2), r_root * math.sin(a * 1.2)),
      ]
      # Root circle disc
      gear = cq.Workplane("XY").circle(r_root).extrude(FACE_W)
      # Add one tooth and pattern it
      tooth = cq.Workplane("XY").polyline(tooth_pts).close().extrude(FACE_W)
      for i in range(N_TEETH):
          angle = i * TOOTH_ARC
          rotated = tooth.rotate((0, 0, 0), (0, 0, 1), angle)
          gear = gear.union(rotated)
      # Center bore
      result = gear.faces(">Z").workplane().hole(BORE_D)

  - title: "Pulley wheel (revolve with V-groove)"
    description: "Revolve a profile with a V-groove to create a pulley wheel with center bore"
    code: |
      import cadquery as cq
      OD = 50.0
      W = 15.0
      GROOVE_D = 8.0
      GROOVE_ANGLE_W = 6.0
      BORE_D = 10.0
      HUB_D = 20.0
      # Half cross-section profile for revolve
      pts = [
          (BORE_D / 2, 0), (OD / 2, 0), (OD / 2, W * 0.3),
          (OD / 2 - GROOVE_D, W / 2),  # groove bottom
          (OD / 2, W * 0.7), (OD / 2, W),
          (BORE_D / 2, W),
      ]
      result = (
          cq.Workplane("XZ")
          .polyline(pts).close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
          .faces(">Z").workplane()
          .hole(BORE_D)
      )

  - title: "Cam profile (eccentric revolve)"
    description: "Revolve an eccentric profile to create a cam with shaft bore"
    code: |
      import cadquery as cq
      CAM_R = 25.0    # max radius
      CAM_MIN = 15.0  # min radius
      THICKNESS = 10.0
      BORE_D = 8.0
      # Build cam using offset circle (eccentric disc)
      ECCENTRICITY = (CAM_R - CAM_MIN) / 2
      MEAN_R = (CAM_R + CAM_MIN) / 2
      cam = (
          cq.Workplane("XY")
          .center(ECCENTRICITY, 0)
          .circle(MEAN_R)
          .extrude(THICKNESS)
      )
      # Bore at true center (0,0)
      bore = cq.Workplane("XY").circle(BORE_D / 2).extrude(THICKNESS)
      result = cam.cut(bore)

  # G. Hinge & Flexure

  - title: "Pin hinge (two plates with knuckles)"
    description: "Two plates with alternating cylinder knuckles (3 total) sharing a common pin hole"
    code: |
      import cadquery as cq
      PLATE_W = 30.0
      PLATE_L = 40.0
      PLATE_T = 3.0
      KNUCKLE_R = 4.0
      KNUCKLE_L = 10.0
      PIN_D = 3.0
      # Left plate with 2 knuckles at positions 0 and 2
      plate_l = cq.Workplane("XY").box(PLATE_W, PLATE_L, PLATE_T)
      for i in [0, 2]:
          k = (
              cq.Workplane("XZ")
              .workplane(offset=PLATE_L / 2)
              .center(0, PLATE_T)
              .circle(KNUCKLE_R)
              .extrude(KNUCKLE_L)
              .translate((0, -i * KNUCKLE_L, 0))
          )
          plate_l = plate_l.union(k)
      # Right plate with 1 knuckle at position 1
      plate_r = cq.Workplane("XY").box(PLATE_W, PLATE_L, PLATE_T).translate((PLATE_W + 2, 0, 0))
      k_mid = (
          cq.Workplane("XZ")
          .workplane(offset=PLATE_L / 2)
          .center(0, PLATE_T)
          .circle(KNUCKLE_R)
          .extrude(KNUCKLE_L)
          .translate((PLATE_W + 2, -KNUCKLE_L, 0))
      )
      plate_r = plate_r.union(k_mid)
      # Return left plate (both plates shown separately)
      result = plate_l

  - title: "Living hinge (thin flexure bridge)"
    description: "Two rigid blocks connected by a thin (0.4mm) flexure bridge for fold-over hinge"
    code: |
      import cadquery as cq
      BLOCK_W = 40.0
      BLOCK_D = 30.0
      BLOCK_H = 5.0
      HINGE_T = 0.4    # thin flex section
      HINGE_L = 2.0    # length of flex zone
      GAP = HINGE_L
      # Left block
      left = cq.Workplane("XY").box(BLOCK_W, BLOCK_D, BLOCK_H)
      # Right block offset by gap
      right = cq.Workplane("XY").box(BLOCK_W, BLOCK_D, BLOCK_H).translate((BLOCK_W + GAP, 0, 0))
      # Thin bridge connecting them at top surface
      bridge = (
          cq.Workplane("XY")
          .workplane(offset=BLOCK_H / 2 - HINGE_T)
          .center(BLOCK_W / 2 + GAP / 2, 0)
          .rect(GAP + 2, BLOCK_D)
          .extrude(HINGE_T)
      )
      result = left.union(right).union(bridge)

  # H. Surface Features & Cutouts

  - title: "Knurled grip (simplified circumferential grooves)"
    description: "Cylinder with circumferential V-grooves via polarArray of small cuts for grip texture"
    code: |
      import cadquery as cq
      GRIP_D = 25.0
      GRIP_H = 40.0
      N_GROOVES = 24
      GROOVE_DEPTH = 1.0
      GROOVE_W = 1.5
      # Solid cylinder
      grip = cq.Workplane("XY").circle(GRIP_D / 2).extrude(GRIP_H)
      # Cut vertical grooves arranged radially
      groove = (
          cq.Workplane("XY")
          .center(GRIP_D / 2, 0)
          .rect(GROOVE_DEPTH * 2, GROOVE_W)
          .extrude(GRIP_H)
      )
      for i in range(N_GROOVES):
          angle = i * (360.0 / N_GROOVES)
          rotated = groove.rotate((0, 0, 0), (0, 0, 1), angle)
          grip = grip.cut(rotated)
      result = grip

  - title: "USB-C port cutout"
    description: "Panel plate with a USB-C shaped rounded-rectangle cutout (8.94 x 3.26mm, R=1.0)"
    code: |
      import cadquery as cq
      PANEL_W = 40.0
      PANEL_H = 30.0
      PANEL_T = 2.0
      USB_W = 8.94
      USB_H = 3.26
      USB_R = 1.0  # corner radius
      result = (
          cq.Workplane("XY")
          .box(PANEL_W, PANEL_H, PANEL_T)
          .faces(">Z").workplane()
          .slot2D(USB_W, USB_H)
          .cutThruAll()
      )

  - title: "D-sub connector cutout (DE-9)"
    description: "Panel plate with trapezoidal D-sub cutout using real DE-9 dimensions (17.7 x 10.0mm)"
    code: |
      import cadquery as cq
      PANEL_W = 50.0
      PANEL_H = 30.0
      PANEL_T = 2.0
      # DE-9 D-sub approximate outline (trapezoidal)
      TOP_W = 16.0
      BOT_W = 12.5
      D_H = 10.0
      # Trapezoidal cutout profile
      trap_pts = [
          (-BOT_W / 2, -D_H / 2),
          (BOT_W / 2, -D_H / 2),
          (TOP_W / 2, D_H / 2),
          (-TOP_W / 2, D_H / 2),
      ]
      panel = cq.Workplane("XY").box(PANEL_W, PANEL_H, PANEL_T)
      cutout = (
          cq.Workplane("XY")
          .workplane(offset=PANEL_T)
          .polyline(trap_pts).close()
          .extrude(-PANEL_T * 2)
      )
      result = panel.cut(cutout)

  # I. Small Items

  - title: "Cable gland / grommet (revolved stepped profile)"
    description: "Revolve a stepped profile to create a cable gland with flange, body, and bore"
    code: |
      import cadquery as cq
      # Profile: flange + body + thread-like steps
      BORE_R = 4.0
      BODY_R = 8.0
      FLANGE_R = 12.0
      pts = [
          (BORE_R, 0), (FLANGE_R, 0), (FLANGE_R, 3),   # flange
          (BODY_R, 3), (BODY_R, 7),                      # neck
          (BODY_R + 1, 7), (BODY_R + 1, 9),              # step/ridge
          (BODY_R, 9), (BODY_R, 18),                     # body
          (BORE_R, 18),                                   # top bore
      ]
      result = (
          cq.Workplane("XZ")
          .polyline(pts).close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )

  - title: "Keychain tag (rounded plate + text + ring hole)"
    description: "Rounded rectangle plate with embossed text and a ring attachment hole"
    code: |
      import cadquery as cq
      TAG_W = 50.0
      TAG_H = 25.0
      TAG_T = 3.0
      CORNER_R = 5.0
      RING_HOLE_D = 5.0
      tag = (
          cq.Workplane("XY")
          .rect(TAG_W, TAG_H)
          .extrude(TAG_T)
          .edges("|Z").fillet(CORNER_R)
      )
      # Ring hole on one end
      tag = tag.faces(">Z").workplane().center(-TAG_W / 2 + 8, 0).hole(RING_HOLE_D)
      # Text on top face
      result = tag.faces(">Z").workplane().center(5, 0).text("TAG", 8.0, 0.5)

# =============================================================================
# ANTI-PATTERN LIBRARY — Common CadQuery Mistakes
# =============================================================================
# Each entry shows wrong code, the error it produces, why it fails, and the fix.

anti_patterns:
  - title: "Fillet before boolean"
    wrong_code: |
      box = cq.Workplane("XY").box(20, 20, 10).edges("|Z").fillet(2.0)
      result = box.union(cq.Workplane("XY").workplane(offset=10).box(10, 10, 5))
    error_message: "StdFail_NotDone: BRep_Tool — filleted edges conflict with boolean operation"
    explanation: "Fillet modifies edge topology. When you union after filleting, the kernel cannot reconcile the changed edges. Always apply fillets and chamfers as the LAST operation, after all booleans are complete."
    correct_code: |
      box = cq.Workplane("XY").box(20, 20, 10)
      combined = box.union(cq.Workplane("XY").workplane(offset=10).box(10, 10, 5))
      result = combined.edges("|Z").fillet(2.0)

  - title: "Shell on complex boolean body"
    wrong_code: |
      body = cq.Workplane("XY").box(40, 40, 20)
      for i in range(5):
          body = body.union(cq.Workplane("XY").center(i*8, 0).circle(3).extrude(25))
      result = body.faces(">Z").shell(-2.0)
    error_message: "StdFail_NotDone: BRep_API — shell operation failed on complex body"
    explanation: "Shell struggles with bodies that have many boolean seams. The kernel cannot offset complex intersecting surfaces reliably. Either shell EARLY (before booleans) or use manual hollowing by cutting a slightly smaller solid from the inside."
    correct_code: |
      body = cq.Workplane("XY").box(40, 40, 20)
      # Shell the simple box FIRST, then add features
      body = body.faces(">Z").shell(-2.0)
      for i in range(5):
          body = body.union(cq.Workplane("XY").center(i*8, 0).circle(3).extrude(25))
      result = body

  - title: "Revolve profile crossing axis"
    wrong_code: |
      pts = [(-5, 0), (15, 0), (15, 30), (-5, 30)]
      result = (
          cq.Workplane("XZ").polyline(pts).close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )
    error_message: "Standard_ConstructionError: profile crosses the revolve axis"
    explanation: "The profile extends to X=-5, which crosses the revolve axis at X=0. ALL profile points must be on the same side of the axis (positive X for revolve around Y). Move the profile so its minimum X coordinate is >= 0."
    correct_code: |
      pts = [(0, 0), (15, 0), (15, 30), (0, 30)]
      result = (
          cq.Workplane("XZ").polyline(pts).close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )

  - title: "Boolean on non-overlapping bodies"
    wrong_code: |
      plate = cq.Workplane("XY").box(40, 40, 5)
      # Cutter sits exactly on top surface — does not penetrate
      cutter = cq.Workplane("XY").workplane(offset=5).box(10, 10, 10)
      result = plate.cut(cutter)
    error_message: "No error — but the cut has no visible effect (silent no-op)"
    explanation: "The cutting tool must OVERLAP the target body. If it only touches a face or sits outside, the boolean produces no change. Always extend the cutter BEYOND the target surface by at least 0.1mm."
    correct_code: |
      plate = cq.Workplane("XY").box(40, 40, 5)
      # Cutter extends 1mm below the top surface into the plate
      cutter = cq.Workplane("XY").workplane(offset=4).box(10, 10, 10)
      result = plate.cut(cutter)

  - title: "translate() wrong signature"
    wrong_code: |
      box = cq.Workplane("XY").box(10, 10, 10)
      result = box.translate(10, 20, 0)
    error_message: "TypeError: translate() takes 2 positional arguments but 4 were given"
    explanation: "CadQuery's translate() expects a SINGLE tuple argument, not three separate numbers. The signature is .translate((x, y, z)) with double parentheses."
    correct_code: |
      box = cq.Workplane("XY").box(10, 10, 10)
      result = box.translate((10, 20, 0))

  - title: "Loft with mismatched profiles"
    wrong_code: |
      result = (
          cq.Workplane("XY").rect(40, 40)
          .workplane(offset=50).circle(20)
          .loft()
      )
    error_message: "Loft produces twisted or self-intersecting geometry"
    explanation: "Lofting between profiles with very different edge counts (4-sided rect to smooth circle) can produce twisted results. Use ruled=True for a cleaner linear transition, or use similar profile types (e.g. roundedRect to circle, or polygons with similar vertex counts)."
    correct_code: |
      result = (
          cq.Workplane("XY").rect(40, 40)
          .workplane(offset=50).circle(20)
          .loft(ruled=True)
      )

  - title: "Fillet radius too large"
    wrong_code: |
      result = (
          cq.Workplane("XY").box(10, 10, 5)
          .edges("|Z").fillet(8.0)
      )
    error_message: "StdFail_NotDone: BRep_Tool — fillet radius exceeds edge length"
    explanation: "The box is 10mm wide but the fillet radius is 8mm. The fillet radius must be LESS than half the shortest adjacent edge. For a 10mm edge, max safe fillet is ~4.5mm. Always keep fillet radius well below half the smallest dimension."
    correct_code: |
      result = (
          cq.Workplane("XY").box(10, 10, 5)
          .edges("|Z").fillet(2.0)
      )

  - title: "Sweep path without .wire()"
    wrong_code: |
      path = (
          cq.Workplane("XZ")
          .moveTo(0, 0).lineTo(0, 30)
          .threePointArc((15, 45), (30, 45))
      )
      result = cq.Workplane("XY").circle(3).sweep(path)
    error_message: "ValueError: Cannot sweep — path is not a Wire object"
    explanation: "Sweep requires a Wire object as path, but chaining line/arc operations produces edges, not a wire. You must call .wire() at the end to combine edges into a single wire before sweeping."
    correct_code: |
      path = (
          cq.Workplane("XZ")
          .moveTo(0, 0).lineTo(0, 30)
          .threePointArc((15, 45), (30, 45))
          .wire()
      )
      result = cq.Workplane("XY").circle(3).sweep(path)

  - title: "Too many chained booleans"
    wrong_code: |
      base = cq.Workplane("XY").box(80, 80, 5)
      for i in range(15):
          col = cq.Workplane("XY").center(i*5 - 35, 0).circle(2).extrude(20)
          base = base.union(col)
      result = base.edges("|Z").fillet(1.0)
    error_message: "OCP kernel crash or tolerance drift — geometry becomes invalid after many booleans"
    explanation: "Each boolean operation accumulates floating-point tolerance errors. After 10+ unions the geometry may become invalid, causing downstream operations (fillet, shell) to crash. Merge in groups of 3-4, or simplify the design to use fewer boolean operations."
    correct_code: |
      base = cq.Workplane("XY").box(80, 80, 5)
      # Build columns as a single compound, then union once
      cols = cq.Workplane("XY").pushPoints([(i*5 - 35, 0) for i in range(15)])
      cols = cols.circle(2).extrude(20)
      result = base.union(cols)

  - title: "Hole on wrong face"
    wrong_code: |
      # Intent: drill holes on TOP face of a box
      result = (
          cq.Workplane("XY").box(40, 40, 10)
          .faces(">X")  # WRONG: this selects the front face, not top
          .workplane()
          .pushPoints([(10, 0), (-10, 0)])
          .hole(5.0)
      )
    error_message: "No crash — but holes appear on the wrong face (front instead of top)"
    explanation: "Face selectors use axis directions: >Z = top, <Z = bottom, >X = front, <X = back, >Y = right, <Y = left. Mixing up axes puts features on the wrong face. Always verify: >Z means the face with the highest Z value (top)."
    correct_code: |
      # Correct: use >Z to select the TOP face
      result = (
          cq.Workplane("XY").box(40, 40, 10)
          .faces(">Z")  # CORRECT: top face
          .workplane()
          .pushPoints([(10, 0), (-10, 0)])
          .hole(5.0)
      )

# =============================================================================
# CADQUERY API QUICK-REFERENCE
# =============================================================================
# Compact reference for error-prone operations.
# Each entry covers signature, key params, and gotchas.

api_reference:
  - operation: "loft()"
    signature: "Workplane.loft(ruled=False, combine=True)"
    returns: "Workplane with a solid lofted between pending wires on different workplanes"
    params:
      - "ruled (bool): True for straight ruled surface between profiles, False for smooth"
      - "combine (bool): True to union with existing solid, False for standalone"
    gotchas:
      - "All profiles must be on separate workplanes at different offsets — use .workplane(offset=N) between each"
      - "Profiles with very different edge counts (e.g. rect→circle) may twist — use ruled=True or similar vertex counts"
      - "Minimum 2 profiles required; profiles must not self-intersect"

  - operation: "sweep()"
    signature: "Workplane.sweep(path, isFrenet=False, transition='right', combine=True)"
    returns: "Workplane with a solid swept along the path wire"
    params:
      - "path (Wire): MUST be a Wire object — call .wire() on your edge chain"
      - "isFrenet (bool): True for Frenet frame (better for helical paths), False for default"
      - "transition ('right'|'round'|'transformed'): how profile handles path curvature"
    gotchas:
      - "Path MUST be a Wire — forgetting .wire() is the #1 sweep error"
      - "Profile should be perpendicular to the path start tangent"
      - "Self-intersecting sweep (tight curves with large profile) produces invalid geometry"

  - operation: "revolve()"
    signature: "Workplane.revolve(angleDegrees=360, axisStart=(0,0,0), axisEnd=(0,1,0), combine=True)"
    returns: "Workplane with a solid of revolution"
    params:
      - "angleDegrees (float): rotation angle, 360 for full revolution"
      - "axisStart, axisEnd: two points defining the revolve axis direction"
    gotchas:
      - "CRITICAL: Profile must be ENTIRELY on one side of the revolve axis — any point crossing it causes Standard_ConstructionError"
      - "For XZ plane revolve around Y: all X coordinates must be >= 0"
      - "Profile must be a closed wire (use .close() after polyline/spline)"

  - operation: "shell()"
    signature: "Workplane.shell(thickness)"
    returns: "Workplane with a hollowed-out solid"
    params:
      - "thickness (float): negative = shell inward (common), positive = shell outward"
      - "The face the operation is called on (.faces('>Z').shell()) is the face REMOVED (opened)"
    gotchas:
      - "Shell FAILS on bodies with complex boolean seams — shell BEFORE booleans when possible"
      - "Thin features or sharp internal corners cause kernel failures — simplify geometry first"
      - "Only one face can be removed per shell call; for multiple openings, shell then cut"

  - operation: "Selector strings"
    signature: ".faces(selector) / .edges(selector) / .wires(selector)"
    returns: "Filtered set of faces, edges, or wires"
    params:
      - ">Z / <Z: max / min along axis (top/bottom face)"
      - "|Z: parallel to Z axis (vertical edges/faces)"
      - "#Z: perpendicular to Z axis (horizontal edges/faces)"
    gotchas:
      - ">X is FRONT face (max X), <X is BACK — not left/right"
      - ">Y is RIGHT, <Y is LEFT — easy to confuse with X"
      - "Compound selectors not supported — chain .faces('>Z').faces('>X') does NOT intersect, it replaces"

  - operation: "Workplane constructor & offsets"
    signature: "cq.Workplane('XY') / .workplane(offset=N) / .transformed(offset, rotate) / .center(x, y)"
    returns: "New workplane for sketching or feature placement"
    params:
      - "'XY'/'XZ'/'YZ': base plane selection — XY is floor, XZ is front wall, YZ is side wall"
      - "offset (float): distance along plane normal from current position"
      - ".center(x, y): shifts the workplane origin within the current plane"
    gotchas:
      - ".workplane(offset=N) is relative to current context face, not absolute Z"
      - ".transformed(offset=(0,0,10), rotate=(45,0,0)) for combined translate+rotate"
      - ".center() does NOT move existing geometry — it only shifts where the NEXT sketch is drawn"

  - operation: "pushPoints / rarray / polarArray"
    signature: ".pushPoints(pts) / .rarray(xSpacing, ySpacing, xCount, yCount) / .polarArray(radius, startAngle, angle, count)"
    returns: "Workplane with pending points for the next operation (hole, circle, cboreHole, etc.)"
    params:
      - "pushPoints: list of (x,y) tuples for arbitrary positions"
      - "rarray: rectangular grid by spacing and count per axis"
      - "polarArray: points on a circle — radius, start angle, sweep angle, count"
    gotchas:
      - "Points are relative to the CURRENT workplane origin, not global coordinates"
      - "The next operation (hole, circle, etc.) executes once at EACH pending point"
      - "polarArray angle=360 distributes evenly around full circle; angle<360 for arc segment"

  - operation: ".tag() / .faces(tag=)"
    signature: ".tag('name') / .faces(tag='name') / .edges(tag='name')"
    returns: "tag() stores a reference to the current state; tag= recalls it for selection"
    params:
      - ".tag('name'): snapshot the current solid state under a name"
      - ".faces('>Z', tag='name'): select faces from the tagged state, not current state"
    gotchas:
      - "Tags survive boolean operations — tag BEFORE a union/cut to reference original faces"
      - "Essential pattern: .tag('base') ... .union(other) ... .faces('>Z', tag='base') to find faces that got merged"
      - "Tag names are strings — must match exactly (case-sensitive)"

# =============================================================================
# REAL-WORLD DIMENSION TABLES
# =============================================================================
# Use these dimensions instead of guessing. All values in mm.

dimension_tables:
  - category: "Metric Fasteners (ISO 4762 / ISO 4032)"
    description: "Socket-head cap screw + hex nut dimensions. All values in mm."
    data:
      - "M2: shaft=2.0, head_dia=3.8, head_h=2.0, nut_af=4.0, nut_h=1.6, clearance_hole=2.4"
      - "M3: shaft=3.0, head_dia=5.5, head_h=3.0, nut_af=5.5, nut_h=2.4, clearance_hole=3.4"
      - "M4: shaft=4.0, head_dia=7.0, head_h=4.0, nut_af=7.0, nut_h=3.2, clearance_hole=4.5"
      - "M5: shaft=5.0, head_dia=8.5, head_h=5.0, nut_af=8.0, nut_h=4.7, clearance_hole=5.5"
      - "M6: shaft=6.0, head_dia=10.0, head_h=6.0, nut_af=10.0, nut_h=5.2, clearance_hole=6.6"
      - "M8: shaft=8.0, head_dia=13.0, head_h=8.0, nut_af=13.0, nut_h=6.8, clearance_hole=9.0"
      - "M10: shaft=10.0, head_dia=16.0, head_h=10.0, nut_af=16.0, nut_h=8.4, clearance_hole=11.0"
      - "M12: shaft=12.0, head_dia=18.0, head_h=12.0, nut_af=18.0, nut_h=10.8, clearance_hole=13.5"

  - category: "Common Electronics Dimensions"
    description: "Board and connector dimensions for enclosure design. All values in mm."
    data:
      - "Raspberry Pi 4: board=85x56, mount_holes=58x49 (M2.5), height_with_ports=17"
      - "Arduino Uno: board=69x53, mount_holes=66x48 (M3), height_with_headers=15"
      - "ESP32 DevKit: board=51x28, pin_rows_spacing=25.4, height=6"
      - "USB-A receptacle: cutout=13.1x5.7, depth=17"
      - "USB-B receptacle: cutout=12.0x11.0, depth=16"
      - "USB-C receptacle: cutout=8.94x3.26, corner_r=1.0, depth=7.5"
      - "Micro-USB receptacle: cutout=7.5x2.7, depth=6"
      - "SD card slot: cutout=12.0x2.5, depth=14; microSD: cutout=12.0x1.5, depth=13"
      - "18650 battery: dia=18.5, length=65.2 (with protection circuit), bare=18.3x65.0"

  - category: "Bearing Dimensions (ISO 15)"
    description: "Common deep-groove ball bearings. ID=inner dia, OD=outer dia, W=width. All mm."
    data:
      - "608 (skateboard): ID=8, OD=22, W=7"
      - "6001: ID=12, OD=28, W=8"
      - "6201: ID=12, OD=32, W=10"
      - "6202: ID=15, OD=35, W=11"
      - "6203: ID=17, OD=40, W=12"
      - "6204: ID=20, OD=47, W=14"
      - "Bearing seat fit: bore=OD+0.000/+0.013 (H7), shaft=ID-0.000/-0.011 (h6)"

  - category: "Common Object Sizes"
    description: "Everyday objects for reference when modeling enclosures or holders. All mm."
    data:
      - "Smartphone (typical): 150x73x8"
      - "Credit card (ISO 7810): 85.6x53.98x0.76"
      - "AA battery: dia=14.5, length=50.5"
      - "AAA battery: dia=10.5, length=44.5"
      - "US quarter: dia=24.26, thickness=1.75; Euro 1: dia=23.25, thickness=2.33"
      - "Standard pen/pencil: dia=7-8, length=140-190"
      - "Coffee mug (typical): dia=80-85, height=95, handle_clearance=30"
      - "Tennis ball: dia=67"

  - category: "Clearance and Press-Fit Tolerances (ISO 286)"
    description: "Standard tolerance pairs for shaft-in-hole fits. Gap values for nominal 10-50mm range."
    data:
      - "H7/g6 (sliding fit): gap=+0.010 to +0.050 — shaft turns freely, good for bearings"
      - "H7/h6 (location fit): gap=0.000 to +0.039 — snug, locates accurately, removable by hand"
      - "H7/k6 (transition fit): gap=-0.018 to +0.021 — may need light press, slight interference possible"
      - "H7/p6 (press fit): gap=-0.042 to -0.001 — requires press or heat, permanent assembly"
      - "Rule of thumb: clearance=+0.1mm per 25mm nominal for easy sliding; press=-0.02 to -0.05mm"
      - "For 3D prints: add +0.2mm to clearance fits to compensate for layer squish and shrinkage"

  - category: "3D Printing Clearance Guidelines (FDM)"
    description: "Practical clearances for FDM printers at 0.2mm layer height. Adjust for resin/SLS."
    data:
      - "Mating flat surfaces (sliding): 0.3-0.5mm gap per side"
      - "Pin in hole (loose fit): hole_dia = pin_dia + 0.4mm"
      - "Pin in hole (snug fit): hole_dia = pin_dia + 0.2mm"
      - "Threaded insert M3: hole_dia=4.0; M4: hole_dia=5.0; M5: hole_dia=6.4"
      - "Snap-fit cantilever: arm_thickness=1.0-1.5mm, deflection<arm_length*0.02"
      - "Living hinge (single-use fold): thickness=0.3-0.5mm, width>=10mm"
      - "Minimum wall thickness: 0.8mm (2 perimeters at 0.4mm nozzle)"
      - "Minimum hole diameter (reliable): 2.0mm"

  - category: "Sheet Metal Bend Radii"
    description: "Minimum inside bend radii by material and thickness. All values in mm."
    data:
      - "Aluminum 5052-H32: t<=1.6 → R=0, t=2.0 → R=1.0, t=3.0 → R=1.5"
      - "Aluminum 6061-T6: t<=1.6 → R=1.0t, t=2.0 → R=1.5t, t=3.0 → R=2.0t"
      - "Mild steel (A36): t<=1.6 → R=0.5t, t=2.0 → R=1.0t, t=3.0 → R=1.5t"
      - "Stainless 304: t<=1.6 → R=1.0t, t=2.0 → R=1.5t, t=3.0 → R=2.0t"
      - "K-factor (neutral axis): 0.33 for air bend, 0.44 for bottoming, 0.50 for coining"
      - "Minimum flange length: 4t + R (material thickness × 4 + bend radius)"
      - "Hole-to-bend distance: >=2.5t + R to avoid distortion"

# =============================================================================
# FEW-SHOT EXAMPLES: Design-to-Code Workflow
# =============================================================================
# Complete workflow demonstrations: user request → design plan → working code.
# These teach the AI the full reasoning chain by example.

few_shot_examples:
  - user_request: "Make me a coffee mug"
    design_plan: |
      Revolve a polyline half-profile to form the mug body (cylinder with thick base).
      Shell the body to create the hollow interior.
      Sweep a circle along a C-shaped arc to form the handle.
      Union handle to body, then fillet the joint edges last.
    code: |
      import cadquery as cq
      # Mug body via revolve of half cross-section
      MUG_OD = 82.0
      MUG_H = 95.0
      BASE_T = 4.0
      WALL = 3.0
      HANDLE_R = 3.5
      body_pts = [
          (0, 0), (MUG_OD / 2, 0), (MUG_OD / 2, MUG_H), (0, MUG_H),
      ]
      body = (
          cq.Workplane("XZ")
          .polyline(body_pts).close()
          .revolve(360, (0, 0, 0), (0, 1, 0))
      )
      # Shell from top, leaving base thick
      body = body.faces(">Z").shell(-WALL)
      # Handle: sweep circle along arc path
      handle_path = (
          cq.Workplane("XZ")
          .moveTo(MUG_OD / 2, MUG_H * 0.75)
          .threePointArc((MUG_OD / 2 + 22, MUG_H * 0.5), (MUG_OD / 2, MUG_H * 0.25))
          .wire()
      )
      handle = cq.Workplane("XY").center(MUG_OD / 2, 0).circle(HANDLE_R).sweep(handle_path)
      result = body.union(handle).edges().fillet(1.0)

  - user_request: "Design a motor mount bracket"
    design_plan: |
      Extrude an L-shaped polyline profile for the bracket body.
      Add a polar array of bolt holes on the vertical face for the motor.
      Add two mounting holes on the horizontal base via pushPoints.
      Apply fillets to all vertical edges last for strength.
    code: |
      import cadquery as cq
      T = 4.0           # plate thickness
      BASE_W = 60.0     # horizontal base width
      BASE_D = 50.0     # depth (extrusion)
      WALL_H = 55.0     # vertical wall height
      MOTOR_BOLT_R = 18.0
      MOTOR_BORE = 24.0
      N_BOLTS = 4
      BOLT_D = 4.5      # M4 clearance
      MOUNT_D = 5.5     # M5 clearance
      # L-profile
      l_pts = [
          (0, 0), (BASE_W, 0), (BASE_W, T),
          (T, T), (T, WALL_H), (0, WALL_H),
      ]
      bracket = cq.Workplane("XZ").polyline(l_pts).close().extrude(BASE_D)
      # Motor bolt circle on vertical face
      bracket = (
          bracket.faces("<X").workplane()
          .polarArray(MOTOR_BOLT_R, 0, 360, N_BOLTS)
          .hole(BOLT_D)
      )
      # Center bore for motor shaft
      bracket = bracket.faces("<X").workplane().hole(MOTOR_BORE)
      # Mounting holes on base
      bracket = (
          bracket.faces("<Z").workplane()
          .pushPoints([(15, BASE_D / 2 - 10), (BASE_W - 15, BASE_D / 2 - 10)])
          .hole(MOUNT_D)
      )
      result = bracket.edges("|Z").fillet(2.0)

  - user_request: "Create an SD card holder"
    design_plan: |
      Start with a box slightly larger than an SD card (26 x 34 x 6mm).
      Fillet vertical edges for rounded corners, then shell from top.
      Cut a slot on the front face for card insertion (24 x 2.5mm).
      Cut a thumb notch on the back wall so the card can be pushed out.
    code: |
      import cadquery as cq
      # SD card: 24x32x2.1mm — holder slightly larger
      W = 28.0
      D = 36.0
      H = 6.0
      WALL = 1.5
      SLOT_W = 24.5
      SLOT_H = 2.5
      NOTCH_W = 12.0
      NOTCH_H = 4.0
      holder = (
          cq.Workplane("XY")
          .box(W, D, H)
          .edges("|Z").fillet(3.0)
          .faces(">Z").shell(-WALL)
      )
      # Card insertion slot on front face
      slot_cutter = (
          cq.Workplane("XZ")
          .workplane(offset=D / 2)
          .center(0, H / 2 - WALL - SLOT_H / 2)
          .rect(SLOT_W, SLOT_H)
          .extrude(-WALL * 3)
      )
      holder = holder.cut(slot_cutter)
      # Thumb notch on back wall
      notch_cutter = (
          cq.Workplane("XZ")
          .workplane(offset=-D / 2)
          .center(0, H / 2)
          .rect(NOTCH_W, NOTCH_H)
          .extrude(WALL * 3)
      )
      result = holder.cut(notch_cutter)

  - user_request: "Make a gear"
    design_plan: |
      Calculate tooth geometry from module and tooth count using math.
      Build a root circle disc, then create one trapezoidal tooth profile.
      Rotate and union the tooth N times around the center.
      Drill a center bore for the shaft.
    code: |
      import cadquery as cq
      import math
      N_TEETH = 16
      MODULE = 2.0
      FACE_W = 10.0
      BORE_D = 8.0
      PD = MODULE * N_TEETH
      OD = PD + 2 * MODULE
      RD = PD - 2.5 * MODULE
      TOOTH_ARC = 360.0 / N_TEETH
      HALF_T = TOOTH_ARC / 4
      r_root = RD / 2
      r_tip = OD / 2
      a = math.radians(HALF_T)
      tooth_pts = [
          (r_root * math.cos(-a * 1.2), r_root * math.sin(-a * 1.2)),
          (r_tip * math.cos(-a * 0.4), r_tip * math.sin(-a * 0.4)),
          (r_tip * math.cos(a * 0.4), r_tip * math.sin(a * 0.4)),
          (r_root * math.cos(a * 1.2), r_root * math.sin(a * 1.2)),
      ]
      gear = cq.Workplane("XY").circle(r_root).extrude(FACE_W)
      tooth = cq.Workplane("XY").polyline(tooth_pts).close().extrude(FACE_W)
      for i in range(N_TEETH):
          rotated = tooth.rotate((0, 0, 0), (0, 0, 1), i * TOOTH_ARC)
          gear = gear.union(rotated)
      result = gear.faces(">Z").workplane().hole(BORE_D)

  - user_request: "Design a phone stand"
    design_plan: |
      Create a flat rectangular base for stability.
      Loft between two angled rectangular profiles to form the upright support.
      Add a small lip/ledge at the bottom of the support to cradle the phone.
      Union all parts together, then fillet edges last.
    code: |
      import cadquery as cq
      # Base plate
      BASE_W = 80.0
      BASE_D = 60.0
      BASE_H = 5.0
      SUPPORT_T = 6.0
      SUPPORT_H = 70.0
      LIP_D = 15.0
      LIP_H = 3.0
      ANGLE = 15  # lean-back angle in degrees
      base = cq.Workplane("XY").box(BASE_W, BASE_D, BASE_H)
      # Angled support via loft between bottom and top profiles
      support = (
          cq.Workplane("XY")
          .workplane(offset=BASE_H)
          .center(0, -BASE_D / 2 + SUPPORT_T / 2)
          .rect(BASE_W * 0.8, SUPPORT_T)
          .workplane(offset=SUPPORT_H)
          .center(0, SUPPORT_H * 0.26)  # lean back
          .rect(BASE_W * 0.7, SUPPORT_T)
          .loft()
      )
      # Lip at bottom-front of support to hold the phone
      lip = (
          cq.Workplane("XY")
          .workplane(offset=BASE_H)
          .center(0, -BASE_D / 2 + LIP_D / 2)
          .rect(BASE_W * 0.6, LIP_D)
          .extrude(LIP_H)
      )
      result = base.union(support).union(lip).edges().fillet(1.5)
